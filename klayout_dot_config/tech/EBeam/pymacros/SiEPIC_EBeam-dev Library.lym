<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>"""
This file is part of the SiEPIC_EBeam_PDK
by Lukas Chrostowski, et al., (c) 2015-2017

This Python file implements a library called "SiEPIC-EBeam-dev"
# - Development components, e.g., Layout only with no Compact Model.
 - Fixed GDS cell components: imported from SiEPIC-EBeam-dev.gds
 - PCells:
    DirectionalCoupler_SeriesRings, DirectionalCoupler_SeriesRings())
    ebeam_dc_halfring_arc, ebeam_dc_halfring_arc())
    DoubleBus_Ring, DoubleBus_Ring())
    TestStruct_DoubleBus_Ring, TestStruct_DoubleBus_Ring())
    TestStruct_DoubleBus_Ring2, TestStruct_DoubleBus_Ring2())
    Waveguide_Route, Waveguide_Route())
    Waveguide_Route_simple, Waveguide_Route_simple())
    Waveguide_Arc, Waveguide_Arc())
    Bent_Coupled_Half_Ring, Bent_Coupled_Half_Ring())
    Bent_CDC_Half_Ring, Bent_CDC_Half_Ring())
    Bezier_Bend, Bezier_Bend())
    Cavity Hole, cavity_hole())
    Tapered Ring, Tapered_Ring())
    Focusing Sub-wavelength grating coupler (fswgc), fswgc() )
    SWG_waveguide, SWG_waveguide())
    SWG_to_strip_waveguide, SWG_to_strip_waveguide())
    strip_to_slot, strip_to_slot() )
    spiral, spiral())
    Waveguide_SBend, Waveguide_SBend())


NOTE: after changing the code, the macro needs to be rerun to install the new
implementation. The macro is also set to "auto run" to install the PCell 
when KLayout is run.

Crash warning:
 https://www.klayout.de/forum/comments.php?DiscussionID=734&amp;page=1#Item_13
 This library has nested PCells. Running this macro with a layout open may
 cause it to crash. Close the layout first before running.

*******
GDS:
*******
imported from SiEPIC-EBeam.gds

*******
PCells:
*******

1) Double-bus ring resonator
class TestStruct_DoubleBus_Ring
class DoubleBus_Ring
def layout_Ring(cell, layer, x, y, r, w, npoints):

2) Waveguide Taper
class ebeam_taper_te1550

3) Bragg grating waveguide
class Bragg_waveguide

Also includes additional functions:

1) code for waveguide bends:
def layout_waveguide_abs(cell, layer, points, w, radius):
def layout_waveguide_rel(cell, layer, start_point, points, w, radius):

2) function for making polygon text
def layout_pgtext(cell, layer, x, y, text, mag):

3) functions for inspecting PCell parameters
def PCell_get_parameter_list ( cell_name, library_name ):
def PCell_get_parameters ( pcell ):


Version history:

Lukas Chrostowski           2015/11/05 - 2015/11/10
 - Double-bus ring resonator
 - waveguide bends
 - PCell parameter functions
 - polygon text
 - PCell calling another PCell - TestStruct_DoubleBus_Ring

Lukas Chrostowski           2015/11/14
 - fix for rounding error in "DoubleBus_Ring"

Lukas Chrostowski           2015/11/15
 - fix for Python 3.4: print("xxx")
 
Lukas Chrostowski           2015/11/17
 - update "layout_waveguide_rel" to use the calculated points_per_circle(radius)

Lukas Chrostowski           2016/05/27
 - SWG_waveguide
 - SWG_to_strip_waveguide

Lukas Chrostowski           2016/06/11
 - spiral

S. Preble                   2016/08/26
 - Double Bus Ring Pin's shifted - text now is in the middle of the pin path
 
Timothy Richards, Adam DeAbreu, Lukas Chrostowski  2017/07/11
 -  Focusing Sub-wavelength grating coupler PCell.

Lukas Chrostowski 2017/12/16
 - compatibility with KLayout 0.25 and SiEPIC-Tools

Mustafa Hammood 2018/02/06
 - EBeam-Dev updates and fixes for compatibility with KLayout 0.25 and SiEPIC-Tools
  
todo:
replace:     
 layout_arc_wg_dbu(self.cell, Layerm1N, x0,y0, r_m1_in, w_m1_in, angle_min_doping, angle_max_doping)
with:
 self.cell.shapes(Layerm1N).insert(Polygon(arc(w_m1_in, angle_min_doping, angle_max_doping) + [Point(0, 0)]).transformed(t))


"""

# import xml before lumapi (SiEPIC.lumerical), otherwise XML doesn't work:
from xml.etree import cElementTree

import math
from SiEPIC.utils import arc, arc_wg, arc_to_waveguide, points_per_circle

from SiEPIC.utils import get_technology, get_technology_by_name

#import numpy as n
MODULE_NUMPY = False

dbu = 0.001

# Import KLayout Python API methods:
# Box, Point, Polygon, Text, Trans, LayerInfo, etc
from pya import *


class ebeam_dc_halfring_arc(PCellDeclarationHelper):
  """
  The PCell declaration for the Directional Coupler Half Ring with Arc for the bus waveguide.
  Consists of a half-ring with 1 waveguide.
  """

  def __init__(self):

    # Important: initialize the super class
    super(ebeam_dc_halfring_arc, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("silayer", self.TypeLayer, "Si Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("r", self.TypeDouble, "Radius", default = 10)
    self.param("w", self.TypeDouble, "Waveguide Width", default = 0.5)
    self.param("g", self.TypeDouble, "Gap", default = 0.2)
    self.param("Lc", self.TypeDouble, "Coupler Length", default = 0.0)
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
    self.param("textl", self.TypeLayer, "Text Layer", default = LayerInfo(10, 0))

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "ebeam_dc_halfring_arc(R=" + ('%.3f' % self.r) + ",g=" + ('%g' % (1000*self.g)) + ")"

  def can_create_from_shape_impl(self):
    return False
    
  def produce_impl(self):
    # This is the main part of the implementation: create the layout

    from math import pi, cos, sin
    from SiEPIC.utils import arc_wg, arc_wg_xy
    from SiEPIC._globals import PIN_LENGTH

    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    shapes = self.cell.shapes
    
    LayerSiN = ly.layer(self.silayer)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)
    TextLayerN = ly.layer(self.textl)

    w = int(round(self.w/dbu))
    r = int(round(self.r/dbu))
    g = int(round(self.g/dbu))
    Lc = int(round(self.Lc/dbu))

    # draw the half-circle
    x = 0
    y = r+w+g
    
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(x-Lc/2, y, r, w, 180, 270))
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(x+Lc/2, y, r, w, 270, 360))
        
    # Pins on the top side:
    pin = Path([Point(-r-Lc/2, y-PIN_LENGTH/2), Point(-r-Lc/2, y+PIN_LENGTH/2)], w)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0,-r-Lc/2, y)
    text = Text ("pin2", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    pin = Path([Point(r+Lc/2, y-PIN_LENGTH/2), Point(r+Lc/2, y+PIN_LENGTH/2)], w)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, r+Lc/2, y)
    text = Text ("pin4", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    if Lc &gt; 0:
      wg1 = Box(-Lc/2, -w/2+w+g, Lc/2, w/2+w+g)
      shapes(LayerSiN).insert(wg1)


    # Create the waveguide
    if Lc &gt; 0:
      wg1 = Box(-Lc/2, -w/2, Lc/2, w/2)
      shapes(LayerSiN).insert(wg1)
      
    dc_angle = 30.0
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(Lc/2,-r, r, w, 90-dc_angle, 90))
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(-Lc/2, -r, r, w, 90, 90+dc_angle))
    y_bottom = round(-2*(1-cos(dc_angle/180.0*pi))*r)
    x_bottom = round(2*sin(dc_angle/180.0*pi)*r)
    t = Trans(Trans.R0,-x_bottom-Lc/2, y_bottom+r)
    self.cell.shapes(LayerSiN).insert(arc_wg(r, w, -90, -90+dc_angle).transformed(t))
    t = Trans(Trans.R0,x_bottom+Lc/2, y_bottom+r)
    self.cell.shapes(LayerSiN).insert(arc_wg(r, w, -90-dc_angle, -90).transformed(t))
    
    wg1 = Box(-r-w/2-w-Lc/2, y_bottom-w/2, -x_bottom-Lc/2, y_bottom+w/2)
    shapes(LayerSiN).insert(wg1)
    wg1 = Box(x_bottom+Lc/2, y_bottom-w/2, r+w/2+w+Lc/2, y_bottom+w/2)
    shapes(LayerSiN).insert(wg1)

    # Pins on the bus waveguide side:
    pin = Path([Point(-r-w/2-w+PIN_LENGTH/2-Lc/2, y_bottom), Point(-r-w/2-w-PIN_LENGTH/2-Lc/2, y_bottom)], w)
    shapes(LayerPinRecN).insert(pin)
    text = Text ("pin1", Trans(Trans.R0, -r-w/2-w-Lc/2, y_bottom))
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    pin = Path([Point(r+w/2+w-PIN_LENGTH/2+Lc/2, y_bottom), Point(r+w/2+w+PIN_LENGTH/2+Lc/2, y_bottom)], w)
    shapes(LayerPinRecN).insert(pin)
    text = Text ("pin3", Trans(Trans.R0, r+w/2+w+Lc/2, y_bottom))
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    # Merge all the waveguide shapes, to avoid any small gaps
    layer_temp = self.layout.layer(LayerInfo(913, 0))
    shapes_temp = self.cell.shapes(layer_temp)
    ShapeProcessor().merge(self.layout,self.cell,LayerSiN,shapes_temp,True,0,True,True)
    self.cell.shapes(LayerSiN).clear()
    shapes_SiN = self.cell.shapes(LayerSiN)
    ShapeProcessor().merge(self.layout,self.cell,layer_temp, shapes_SiN,True,0,True,True)
    self.cell.shapes(layer_temp).clear()


    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
    dev = Box(-r-w/2-w-Lc/2, y_bottom-w/2-w, r+w/2+w+Lc/2, y )
    shapes(LayerDevRecN).insert(dev)


    # Compact model information
    t = Trans(Trans.R0, r/4, 0)
    text = Text ("Lumerical_INTERCONNECT_library=Design kits/ebeam_v1.2", t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = self.r*0.017/dbu
    t = Trans(Trans.R0, r/4, r/4)
    text = Text ('Component=ebeam_dc_halfring_arc_te1550', t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = self.r*0.017/dbu
    t = Trans(Trans.R0, r/4, r/2)
    text = Text ('Spice_param:wg_width=%.3fu gap=%.3fu radius=%.3fu Lc=%.3fu'%(self.w,self.g,self.r,self.Lc), t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = self.r*0.017/dbu

    print("Done drawing the layout for - ebeam_dc_halfring_arc: %.3f-%g" % ( self.r, self.g) )




class spiral(PCellDeclarationHelper):
  """
  Input: 
  """

  def __init__(self):

    # Important: initialize the super class
    super(spiral, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("length", self.TypeDouble, "Target Waveguide length", default = 10.0)     
    self.param("wg_width", self.TypeDouble, "Waveguide width (microns)", default = 0.5)     
    self.param("min_radius", self.TypeDouble, "Minimum radius (microns)", default = 5)     
    self.param("wg_spacing", self.TypeDouble, "Waveguide spacing (microns)", default = 1)     
    self.param("spiral_ports", self.TypeInt, "Ports on the same side? 0/1", default = 0)
    self.param("layer", self.TypeLayer, "Layer", default = TECHNOLOGY['Si'])
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "spiral_%s-%.3f-%.3f-%.3f" % \
    (self.length, self.wg_width, self.min_radius, self.wg_spacing)
  
  def coerce_parameters_impl(self):
    pass

  def can_create_from_shape(self, layout, shape, layer):
    return False
    
  def produce_impl(self):
  
    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    shapes = self.cell.shapes

    LayerSi = self.layer
    LayerSiN = ly.layer(LayerSi)
    #LayerSiSPN = ly.layer(LayerSiSP)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)
    LayerTextN = ly.layer(get_technology()['Text'])

    # draw spiral
    from math import pi, cos, sin, log, sqrt
    
    # Archimedes spiral
    # r = b + a * theta
    b = self.min_radius
    spacing = self.wg_spacing+self.wg_width;
    a = 2*spacing/(2*pi)


    # area, length, turn tracking for spiral
    area = 0
    spiral_length = 0
    turn = -1
    
    while spiral_length &lt; self.length:
      turn +=1

      # Spiral #1
      pts = []
      # local radius:
      r = 2*b + a * turn * 2 * pi - self.wg_width/2
      # number of points per circle:
      npoints = int(points_per_circle(r))
      # increment, in radians, for each point:
      da = 2 * pi / npoints  
      # draw the inside edge of spiral
      for i in range(0, npoints+1):
        t = i*da
        xa = (a*t + r) * cos(t);
        ya = (a*t + r) * sin(t);
        pts.append(Point.from_dpoint(DPoint(xa/dbu, ya/dbu)))
      # draw the outside edge of spiral
      r = 2*b + a * turn * 2 * pi + self.wg_width/2
      npoints = int(points_per_circle(r))
      da = 2 * pi / npoints  
      for i in range(npoints, -1, -1):
        t = i*da
        xa = (a*t + r) * cos(t);
        ya = (a*t + r) * sin(t);
        pts.append(Point.from_dpoint(DPoint(xa/dbu, ya/dbu)))
      polygon = Polygon(pts)
      area += polygon.area()
      shapes(LayerSiN).insert(polygon)

      # Spiral #2
      pts = []
      # local radius:
      r = 2*b + a * turn * 2 * pi - self.wg_width/2 - spacing
      # number of points per circle:
      npoints = int(points_per_circle(r))
      # increment, in radians, for each point:
      da = 2 * pi / npoints  
      # draw the inside edge of spiral
      for i in range(0, npoints+1):
        t = i*da + pi
        xa = (a*t + r) * cos(t);
        ya = (a*t + r) * sin(t);
        pts.append(Point.from_dpoint(DPoint(xa/dbu, ya/dbu)))
      # draw the outside edge of spiral
      r = 2*b + a * turn * 2 * pi + self.wg_width/2  - spacing
      npoints = int(points_per_circle(r))
      da = 2 * pi / npoints  
      for i in range(npoints, -1, -1):
        t = i*da + pi
        xa = (a*t + r) * cos(t);
        ya = (a*t + r) * sin(t);
        pts.append(Point.from_dpoint(DPoint(xa/dbu, ya/dbu)))
      polygon = Polygon(pts)
      area += polygon.area()
      shapes(LayerSiN).insert(polygon)

      # waveguide length:
      spiral_length = area / self.wg_width * dbu*dbu + 2 * pi * self.min_radius

    if self.spiral_ports:
      # Spiral #1 extra 1/2 arm
      turn = turn + 1
      pts = []
      # local radius:
      r = 2*b + a * turn * 2 * pi - self.wg_width/2
      # number of points per circle:
      npoints = int(points_per_circle(r))
      # increment, in radians, for each point:
      da = pi / npoints  
      # draw the inside edge of spiral
      for i in range(0, npoints+1):
        t = i*da
        xa = (a*t + r) * cos(t);
        ya = (a*t + r) * sin(t);
        pts.append(Point.from_dpoint(DPoint(xa/dbu, ya/dbu)))
      # draw the outside edge of spiral
      r = 2*b + a * turn * 2 * pi + self.wg_width/2
      npoints = int(points_per_circle(r))
      da = pi / npoints  
      for i in range(npoints, -1, -1):
        t = i*da
        xa = (a*t + r) * cos(t);
        ya = (a*t + r) * sin(t);
        pts.append(Point.from_dpoint(DPoint(xa/dbu, ya/dbu)))
      polygon = Polygon(pts)
      area += polygon.area()
      shapes(LayerSiN).insert(polygon)
      turn = turn - 1
      # waveguide length:
      spiral_length = area / self.wg_width * dbu*dbu + 2 * pi * self.min_radius

    # Centre S-shape connecting waveguide        
    #layout_arc_wg_dbu(self.cell, LayerSiN, -b/dbu, 0, b/dbu, self.wg_width/dbu, 0, 180)
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(-b/dbu, 0, b/dbu, self.wg_width/dbu, 0, 180))
    #layout_arc_wg_dbu(self.cell, LayerSiN, b/dbu, 0, b/dbu, self.wg_width/dbu, 180, 0)
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(b/dbu, 0, b/dbu, self.wg_width/dbu, 180, 180))
    
    print("spiral length: %s microns" % spiral_length)

    # Pins on the waveguide:
    from SiEPIC._globals import PIN_LENGTH as pin_length
    
    x = -(2*b + a * (turn+1) * 2 * pi)/dbu
    w = self.wg_width / dbu
    t = Trans(Trans.R0, x,0)
    pin = Path([Point(0,-pin_length/2), Point(0,pin_length/2)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin2", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    if self.spiral_ports:
      x = -(2*b + a * (turn+1.5) * 2 * pi)/dbu
    else:
      x = (2*b + a * (turn+1) * 2 * pi)/dbu
    t = Trans(Trans.R0, x,0)
    pin = Path([Point(0,-pin_length/2), Point(0,pin_length/2)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin1", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    # Compact model information
    t = Trans(Trans.R0, -abs(x), 0)
    text = Text ('Length=%.3fu' % spiral_length, t)
    shape = shapes(LayerTextN).insert(text)
    shape.text_size = abs(x)/8
    t = Trans(Trans.R0, 0, 0)
    text = Text ('Lumerical_INTERCONNECT_library=Design kits/ebeam_v1.2', t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu
    t = Trans(Trans.R0, 0, w*2)
    text = Text ('Component=ebeam_wg_strip_1550', t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu
    t = Trans(Trans.R0, 0, -w*2)
    text = Text \
      ('Spice_param:wg_length=%.3fu wg_width=%.3fu min_radius=%.3fu wg_spacing=%.3fu' %\
      (spiral_length, self.wg_width, (self.min_radius), self.wg_spacing), t )
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu

    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
    x = abs(x)
    npoints = int(points_per_circle(x) /100 )
    da = 2 * pi / npoints # increment, in radians
    r=x + 2 * self.wg_width/dbu
    pts = []
    for i in range(0, npoints+1):
      pts.append(Point.from_dpoint(DPoint(r*cos(i*da), r*sin(i*da))))
    shapes(LayerDevRecN).insert(Polygon(pts))

    print("spiral done.")






class cavity_hole(PCellDeclarationHelper):
  """
  The PCell declaration for the cavity hole.
  This is an example of how to perform inversion operations
  by Jaspreet, Jingda, and Lukas
  """

  def __init__(self):

    # Important: initialize the super class
    super(cavity_hole, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("x", self.TypeDouble, "x coordinate", default = 0)
    self.param("y", self.TypeDouble, "y coordinate", default = 0)
    self.param("radius", self.TypeDouble, "hole radius", default = 10)
    self.param("gap", self.TypeDouble, "half of the gap between surrounding holes (microns)", default = 2)
    self.param("LayerSi", self.TypeLayer, "Si Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
    

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "cavity_hole(R=" + ('%.3f-%.3f' % (self.radius,self.gap) ) + ")"

  def can_create_from_shape(self, layout, shape, layer):
    return False


  def produce_impl(self):   
    import pya
    from operator import xor
    from math import pi, cos, sin
    
    dbu = self.layout.dbu
    ly = self.layout
    shapes = self.cell.shapes

    #Layers definitions
    LayerSi = self.layer
    LayerSiN = ly.layer(self.LayerSi)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)
    TECHNOLOGY = get_technology_by_name('EBeam')
    LayerTextN = TECHNOLOGY['Text']
    # cell: layout cell to place the layout
    # LayerSiN: which layer to use
    # x, y: location of the origin
    # r: radius
    # w: waveguide width
    # length units in dbu
    
    x = self.x/dbu
    y = self.y/dbu
    r = self.radius/dbu
    r= r/2
    w = 2*r;
    
    gap = self.gap/dbu #gap between one hole to another

  
    # function to generate points to create a circle
    def circle(x,y,r):
      npts = 32
      theta = 2 * math.pi / npts # increment, in radians
      pts = []
      for i in range(0, npts):
        pts.append(Point.from_dpoint(DPoint((x+r*math.cos(i*theta))/1, (y+r*math.sin(i*theta))/1)))
      return pts
  
    
    #rectangular shapes
    side_gap = gap # half of gap between surrounding holes
    dx = side_gap + (2*r)
    dy = side_gap + (2*r)

    Si_slab = Region()
    Si_slab.insert(Box(-dx/2, -dy/2, dx/2, dy/2))
     
    # Circle 
    hole = Region()
    hole_cell = circle(0,0,r)
    hole_poly = Polygon(hole_cell)  
    hole_t = hole_poly.transformed(Trans(Trans.R0, x,y))
    hole.insert(hole_t)           

    # perform inversion:
    phc = Si_slab - hole
    self.cell.shapes(LayerSiN).insert(phc)
    # inversion can also be done by performing the XOR function
    # upper_poly = xor(Region(Polygon(circleu_pts)),Region(Polygon(rectu_pts)))

    
    return "cavity_hole(R=" + ('%.3f-%.3f' % (r,gap) ) + ")"





class strip_to_slot(PCellDeclarationHelper):
  """
  The PCell declaration for the strip_to_slot.
  draft by Lukas Chrostowski july 24, 2017
  based on https://www.osapublishing.org/oe/fulltext.cfm?uri=oe-21-16-19029&amp;id=259920
  """

  def __init__(self):

    # Important: initialize the super class
    super(strip_to_slot, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("silayer", self.TypeLayer, "Si Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("r", self.TypeDouble, "Radius", default = 10)
    self.param("w", self.TypeDouble, "Waveguide Width", default = 0.5)
    self.param("g", self.TypeDouble, "Gap", default = 0.2)
    self.param("Lc", self.TypeDouble, "Coupler Length", default = 0.0)
    self.param("orthogonal_identifier", self.TypeInt, "Orthogonal identifier (1=TE, 2=TM)", default = 1)     
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
    self.param("textl", self.TypeLayer, "Text Layer", default = LayerInfo(10, 0))

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "strip_to_slot(R=" + ('%.3f' % self.r) + ",g=" + ('%g' % (1000*self.g)) + ",Lc=" + ('%g' % (1000*self.Lc)) + ",orthogonal_identifier=" + ('%s' % self.orthogonal_identifier) + ")"

  def can_create_from_shape_impl(self):
    return False
    
  def produce_impl(self):
    # This is the main part of the implementation: create the layout

    from math import pi, cos, sin

    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    shapes = self.cell.shapes
    
    LayerSi = self.silayer
    LayerSiN = ly.layer(LayerSi)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)
    TextLayerN = ly.layer(self.textl)

    
    w = int(round(self.w/dbu))
    w = 0.5/dbu
    r = int(round(self.r/dbu))
    r = 10/dbu
    g = int(round(self.g/dbu))
    g = 0.1/dbu
    Lc = int(round(self.Lc/dbu))

    # draw the half-circle
    x = 0
    y = r+0.35/dbu+g
#    layout_arc_wg_dbu(self.cell, LayerSiN, x-Lc/2, y, r, w, 180, 270)
    #layout_arc_wg_dbu(self.cell, LayerSiN, x+Lc/2, y, r, 0.2/dbu, 270, 360)

    t = Trans(Trans.R0,x+Lc/2, y)
    self.cell.shapes(LayerSiN).insert(Path(arc(r, 270, 360),0.2/dbu).transformed(t).simple_polygon())

    # Draw 500 to 200 nm polygon
    pts = []
    pts.append(Point.from_dpoint(DPoint(0/dbu, (-0.35+0.6)/dbu)))
    pts.append(Point.from_dpoint(DPoint(0/dbu, (-0.85+0.6)/dbu)))
    pts.append(Point.from_dpoint(DPoint(-10/dbu, (-0.55+0.6)/dbu)))
    pts.append(Point.from_dpoint(DPoint(-10/dbu, (-0.35+0.6)/dbu)))
    polygon = Polygon(pts)
    shapes(LayerSiN).insert(polygon)

    # Create the top left 1/2 waveguide
    wg1 = Box(-10/dbu, (-0.35+0.6+0.3)/dbu, 0, (-0.55+0.6+0.3)/dbu)
    shapes(LayerSiN).insert(wg1)

    
    # Create the pins, as short paths:
    pin_length = PIN_LENGTH # database units, = 0.2 microns
 
    # Create the waveguide
    wg1 = Box(0, -w/2, r+w/2+w+Lc/2, w/2)
    shapes(LayerSiN).insert(wg1)

    # Pins on the bus waveguide side:
    pin = Path([Point(-10.1/dbu, (-0.35+0.6+0.05)/dbu), Point(-9.9/dbu, (-0.35+0.6+0.05)/dbu)], w)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, -10/dbu, (-0.35+0.6+0.05)/dbu)
    text = Text ("pin1", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    pin = Path([Point(r+w/2+w-pin_length/2+Lc/2, 0), Point(r+w/2+w+pin_length/2+Lc/2, 0)], w)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, r+w/2+w+Lc/2, 0)
    text = Text ("pin2", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
    dev = Box(-10/dbu, -w/2-w, r+w/2+w+Lc/2, y )
    shapes(LayerDevRecN).insert(dev)

    print("Done drawing the layout for - strip_to_slot: %.3f-%g" % ( self.r, self.g) )



class fswgc(PCellDeclarationHelper):
  """
  Focusing Sub-wavelength grating coupler PCell implementation.
  Analytical design based on "Grating Coupler Design Based on Silicon-On-Insulator", Yun Wang (2013). Master's Thesis, University of British Columbia, Canada
  Some PCell implementation adapted from the SiEPIC_EBeam library by Dr. Lukas Chrostowski, University of British Columbia, Canada
 
  Separate modelling (e.g. Lumerical MODE) is required to determine the "grating effective index" parameter for a given device layer thickness,
  cladding type, and period/duty cycle/fill factor.

  Script written by Timothy Richards (Simon Fraser University, BC, Canada) and Adam DeAbreu (Simon Fraser University, BC, Canada)

  Changelog

  2017-07-07 - initial publish
  2017-07-07 - change library &amp; component names; commit to github

  TO-DO:
  - implement mode solver here, or call Lumerical MODE to calculate
  - needs to be verified experimentally
  - default parameters are not correct; compare with "ebeam_gc_te1550"

  Input: 
  
  """

  def __init__(self):

    # Important: initialize the super class
    super(fswgc, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters  
    self.param("wavelength", self.TypeDouble, "Design Wavelength (micron)", default = 1.55)  
    self.param("n_t", self.TypeDouble, "Cladding Index", default = 1.0)
    self.param("n_e", self.TypeDouble, "Grating Effective Index", default = 2.75618)
    self.param("angle_e", self.TypeDouble, "Taper Angle (deg)", default = 35.0)
    self.param("grating_length", self.TypeDouble, "Grating Length (micron)", default = 15.0)
    self.param("taper_length", self.TypeDouble, "Taper Length (micron)", default = 19.0)
    self.param("dc", self.TypeDouble, "Duty Cycle", default = 0.488193)
    self.param("period", self.TypeDouble, "Grating Period", default = 1.18939)
    self.param("ff", self.TypeDouble, "Fill Factor", default = 0.244319)
    self.param("t", self.TypeDouble, "Waveguide Width (micron)", default = 0.5)
    self.param("theta_c", self.TypeDouble, "Insertion Angle (deg)", default = -31.0)
    
    # Layer parameters
    self.param("layer", self.TypeLayer, "Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "fswgc_%.1f-%.2f-%.2f-%.2f-%.2f-%.2f-%.2f-%.2f" % \
    (self.wavelength, self.theta_c, self.period, self.dc, self.ff, self.angle_e, self.taper_length, self.t)
    
#    return "temporary placeholder"
    
  def coerce_parameters_impl(self):
    pass

  def can_create_from_shape(self, layout, shape, layer):
    return False
    
  def produce_impl(self):
    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    shapes = self.cell.shapes

    LayerSi = self.layer
    LayerSiN = ly.layer(LayerSi)
    LayerSiSPN = ly.layer(LayerSi)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)
    LayerTextN = get_technology()['Text']

    from math import pi, cos, sin, log, sqrt, tan
    from SiEPIC.utils import points_per_circle
    
    lambda_0 = self.wavelength                   ##um wavelength of light
#    pin_length =0.0                 ##um extra nub for the waveguide attachment
    
    # Geometry
    wh = self.period*self.dc                   ##thick grating
    wl = self.ff*(self.period - wh)            ## thin grating
    spacing = (self.period - wh - wl)/2   ##space between thick and thin
    
    gc_number = int(round(self.grating_length/self.period)) ##number of periods
    e = self.n_t*sin((pi/180)*self.theta_c)/self.n_e
    N = round(self.taper_length*(1+e)*self.n_e/lambda_0) ##allows room for the taper

    start = (pi - (pi/180)*self.angle_e/2)
    stop = (pi + (pi/180)*self.angle_e/2)
              
    # Draw coupler grating.
    for j in range(gc_number):

        # number of points in the arcs:
        # calculate such that the vertex &amp; edge placement error is &lt; 0.5 nm.
        #   see "SiEPIC_EBeam_functions - points_per_circle" for more details
        radius = N*lambda_0 / ( self.n_e*( 1 - e )) + j*self.period + spacing
        seg_points = int(points_per_circle(radius/dbu)/360.*self.angle_e) # number of points grating arc
        theta_up = []
        for m in range(seg_points+1):    
          theta_up = theta_up + [start + m*(stop-start)/seg_points]
        theta_down = theta_up[::-1]

        ##small one
        r_up = []
        r_down = []
        for k in range(len(theta_up)):
          r_up = r_up + [N*lambda_0 / ( self.n_e*( 1 - e*cos(float(theta_up[k])) )) + j*self.period + spacing]
        r_down = r_up[::-1]
    
        xr = []
        yr = []
        for k in range(len(theta_up)):
          xr = xr + [r_up[k]*cos(theta_up[k])]
          yr = yr + [r_up[k]*sin(theta_up[k])]
    
        xl = []
        yl = []
        for k in range(len(theta_down)):
          xl = xl + [(r_down[k] + wl)*cos(theta_down[k])]
          yl = yl + [(r_down[k] + wl)*sin(theta_down[k])]
    
        x = xr + xl
        y = yr + yl
    
        pts = []
        for i in range(len(x)):
            pts.append(Point.from_dpoint(DPoint(x[i]/dbu, y[i]/dbu)))
        #small_one = core.Boundary(points)
        
        polygon = Polygon(pts)
        shapes(LayerSiN).insert(polygon)
        
        ##big one
        r_up = []
        r_down = []
        for k in range(len(theta_up)):
          r_up = r_up + [N*lambda_0 / ( self.n_e*( 1 - e*cos(float(theta_up[k])) )) + j*self.period + 2*spacing+ wl]
        r_down = r_up[::-1]
    
        xr = []
        yr = []
        for k in range(len(theta_up)):
          xr = xr + [r_up[k]*cos(theta_up[k])]
          yr = yr + [r_up[k]*sin(theta_up[k])]
    
        xl = []
        yl = []
        for k in range(len(theta_down)):
          xl = xl + [(r_down[k] + wh)*cos(theta_down[k])]
          yl = yl + [(r_down[k] + wh)*sin(theta_down[k])]
    
        x = xr + xl
        y = yr + yl
        
        pts = []
        for i in range(len(x)):
            pts.append(Point.from_dpoint(DPoint(x[i]/dbu, y[i]/dbu)))
        
        polygon = Polygon(pts)
        shapes(LayerSiN).insert(polygon)
      
    # Taper section
    r_up = []
    r_down = []
    for k in range(len(theta_up)):  
      r_up = r_up + [N*lambda_0 / ( self.n_e*( 1 - e*cos(float(theta_up[k])) ))]
    r_down = r_up[::-1]
     
    xl = []
    yl = []  
    for k in range(len(theta_down)):
      xl = xl + [(r_down[k])*cos(theta_down[k])]
      yl = yl + [(r_down[k])*sin(theta_down[k])]
      
    yr = [self.t/2., self.t/2., -self.t/2., -self.t/2.]
    
    yl_abs = []
    for k in range(len(yl)):
      yl_abs = yl_abs + [abs(yl[k])]
    
    y_max = max(yl_abs)
    iy_max = yl_abs.index(y_max)
      
    L_o = (y_max - self.t/2)/tan((pi/180)*self.angle_e/2)
      
    xr = [L_o+xl[iy_max], 0, 0, L_o+xl[iy_max]]
     
    x = xr + xl
    y = yr + yl  

    pts = []
    for i in range(len(x)):
      pts.append(Point.from_dpoint(DPoint(x[i]/dbu, y[i]/dbu)))
    
    polygon = Polygon(pts)
    shapes(LayerSiN).insert(polygon)


    # Pin on the waveguide:
    from SiEPIC._globals import PIN_LENGTH as pin_length
    x = 0
    t = Trans(Trans.R0, x,0)
    pin = Path([Point(-pin_length/2,0), Point(pin_length/2,0)], self.t/dbu)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin1", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu


    # Device recognition layer 
    yr = sin(start) * (N*lambda_0 / ( self.n_e*( 1 - e*cos(float(start)) )) + gc_number*self.period + spacing)
    box1 = Box(-(self.grating_length+self.taper_length)/dbu-pin_length*2, yr/dbu, 0, -yr/dbu)
    shapes(LayerDevRecN).insert(box1)



class SWG_to_strip_waveguide(PCellDeclarationHelper):
  """
  Input: length, period_strip, period_swg, wg_width_strip, wg_width_swg, duty_strip, duty_swg
  continuously (linearly) variable period, width, duty along the length
  """

  def __init__(self):

    # Important: initialize the super class
    super(SWG_to_strip_waveguide, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("length", self.TypeDouble, "Waveguide length", default = 10.0)     
    self.param("taper_fraction", self.TypeDouble, "Strip taper length fraction (0 to 1)", default = 0.9)     
    self.param("period_strip", self.TypeDouble, "SWG Period at strip end (microns)", default = 0.200)     
    self.param("period_swg", self.TypeDouble, "SWG Period at SWG end (microns)", default = 0.200)     
    self.param("wg_width_strip", self.TypeDouble, "Waveguide width at strip end (microns)", default = 0.5)     
    self.param("wg_width_swg", self.TypeDouble, "Waveguide width at SWG end (microns)", default = 0.4)     
    self.param("wg_width_taper", self.TypeDouble, "Waveguide width at strip nanotaper end (microns)", default = 0.06)     
    self.param("duty_strip", self.TypeDouble, "SWG duty cycle at strip end (0 to 1)", default = 0.500)     
    self.param("duty_swg", self.TypeDouble, "SWG duty cycle at SWG end (0 to 1)", default = 0.700)     
    self.param("layer", self.TypeLayer, "Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "SWG_to_strip_waveguide_%s-%.3f-%.3f-%.3f" % \
    (self.length, self.period_swg, self.wg_width_swg, self.duty_swg)
  
  def coerce_parameters_impl(self):
    pass

  def can_create_from_shape(self, layout, shape, layer):
    return False
    
  def produce_impl(self):
  
    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    shapes = self.cell.shapes

    LayerSi = self.layer
    LayerSiN = ly.layer(LayerSi)
    LayerSiSPN = ly.layer(LayerSi)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)

    # Determine the period such that the waveguide length is as desired.  Slight adjustment to period
    N_boxes = int(round(self.length / (self.period_swg+self.period_strip)*2.0)-0.5)
    grating_period = self.length / (N_boxes) / dbu
    print("N boxes: %s, grating_period: %s" % (N_boxes, grating_period) )
    
    # Draw the Bragg grating:
    
    x = - self.period_swg * self.duty_swg / 2 / dbu
    for i in range(0,N_boxes+1):
      local_duty = 1.0 * (N_boxes - i) / N_boxes * self.duty_swg + 1.0*i / N_boxes * self.duty_strip 
      local_period = (1.0*(N_boxes - i) / N_boxes * self.period_swg + 1.0*i / N_boxes * self.period_strip )/dbu
      local_wg_width = (1.0*(N_boxes - i) / N_boxes * self.wg_width_swg + 1.0*i / N_boxes * self.wg_width_strip  ) /dbu
      if (i==0) | (i==N_boxes):
        print("local_duty: %s, local_period: %s, local_wg_width: %s" % (local_duty, local_period, local_wg_width) )     
      local_box_width = int(round(local_period*local_duty))
#      x = int(round((i * local_period - local_box_width/2)))
      box1 = Box(x, -local_wg_width/2, x + local_box_width, local_wg_width/2)
      shapes(LayerSiN).insert(box1)
      x = x + int(round((local_period)))
#    i = i + 1
#    x = int(round((i * grating_period)))
#    box1 = Box(x, -half_w, x + box_width, half_w)
#    shapes(LayerSiN).insert(box1)
    length = self.length / dbu

    # Triangle
    taper_length = int(round(self.taper_fraction * self.length / dbu))
    w1 = int(round(self.wg_width_taper/dbu))
    w2 = int(round(self.wg_width_strip/dbu))
    pts = [Point(length-taper_length,-w1/2), Point(length-taper_length,w1/2), Point(length,w2/2), Point(length,-w2/2)]
    shapes(LayerSiN).insert(Polygon(pts))


    # Pins on the waveguide:
    
    from SiEPIC._globals import PIN_LENGTH as pin_length
    
#    pin_length = self.period_swg * self.duty_swg / dbu
    w = self.wg_width_swg / dbu
    t = Trans(Trans.R0, 0,0)
    pin = Path([Point(pin_length/2, 0), Point(-pin_length/2, 0)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin1", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    w = max ( self.wg_width_strip, self.wg_width_taper) / dbu
    t = Trans(Trans.R0, length,0)
    pin = Path([Point(-pin_length/2, 0), Point(pin_length/2, 0)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin2", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    # Compact model information
    t = Trans(Trans.R0, 0, 0)
    text = Text ('Lumerical_INTERCONNECT_library=Design kits/ebeam_v1.2', t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu
    t = Trans(Trans.R0, length/10, 0)
    text = Text ('Component=NO_MODEL_AVAILABLE', t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu
    t = Trans(Trans.R0, length/9, -w*2)
    text = Text \
      ('Spice_param:length=%.3fu period_swg=%.3fu period_strip=%.3fu wg_width_swg=%.3fu wg_width_strip=%.3fu duty_swg=%.3f duty_strip=%.3f ' %\
      (self.length, self.period_swg, (self.period_strip), self.wg_width_swg, self.wg_width_strip, self.duty_swg, self.duty_strip), t )
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu

    
    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
    points = [pya.Point(0,0), pya.Point(length, 0)]
    path = pya.Path(points,w)
    path = pya.Path(points,w*3)
    shapes(LayerDevRecN).insert(path.simple_polygon())






class SWG_waveguide(PCellDeclarationHelper):
  """
  Input: length, target_period, wg_width, width, duty
  """

  def __init__(self):

    # Important: initialize the super class
    super(SWG_waveguide, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("length", self.TypeDouble, "Waveguide length", default = 10.0)     
    self.param("target_period", self.TypeDouble, "Target period (microns)", default = 0.200)     
    self.param("wg_width", self.TypeDouble, "Waveguide width", default = 0.5)     
    self.param("duty", self.TypeDouble, "Duty Cycle (0 to 1)", default = 0.7)
    self.param("layer", self.TypeLayer, "Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
#    self.param("textl", self.TypeLayer, "Text Layer", default = LayerInfo(10, 0))

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "SWG_waveguide_%s-%.3f-%.3f-%.3f" % \
    (self.length, self.target_period, self.wg_width, self.duty)
  
  def coerce_parameters_impl(self):
    pass

  def can_create_from_shape(self, layout, shape, layer):
    return False
    
  def produce_impl(self):
  
    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    shapes = self.cell.shapes

    LayerSi = self.layer
    LayerSiN = ly.layer(LayerSi)
    #LayerSiSPN = ly.layer(LayerSiSP)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)

    # Determine the period such that the waveguide length is as desired.  Slight adjustment to period
    N_boxes = int(round(self.length / self.target_period-0.5))
    grating_period = self.length / (N_boxes) / dbu
    print("N boxes: %s, grating_period: %s" % (N_boxes, grating_period) )
    
    # Draw the Bragg grating:
    box_width = int(round(grating_period*self.duty))
    
    w = self.wg_width / dbu
    half_w = w/2
    for i in range(0,N_boxes+1):
      x = int(round((i * grating_period - box_width/2)))
      box1 = Box(x, -half_w, x + box_width, half_w)
      shapes(LayerSiN).insert(box1)
#    i = i + 1
#    x = int(round((i * grating_period)))
#    box1 = Box(x, -half_w, x + box_width, half_w)
#    shapes(LayerSiN).insert(box1)
    length = self.length / dbu

    # Pins on the waveguide:
    from SiEPIC._globals import PIN_LENGTH as pin_length
#    pin_length = box_width
    t = Trans(Trans.R0, 0,0)
    pin = Path([Point(pin_length/2, 0), Point(-pin_length/2, 0)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin1", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    t = Trans(Trans.R0, length,0)
    pin = Path([Point(-pin_length/2, 0), Point(pin_length/2, 0)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin2", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    # Compact model information
    t = Trans(Trans.R0, 0, 0)
    text = Text ('Lumerical_INTERCONNECT_library=Design kits/ebeam_v1.2', t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu
    t = Trans(Trans.R0, length/10, 0)
    text = Text ('Component=NO_MODEL_AVAILABLE', t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu
    t = Trans(Trans.R0, length/9, -box_width*2)
    text = Text \
      ('Spice_param:length=%.3fu target_period=%.3fu grating_period=%.3fu wg_width=%.3fu duty=%.3f ' %\
      (self.length, self.target_period, round(grating_period)*dbu, self.wg_width, self.duty), t )
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu

    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
    points = [pya.Point(0,0), pya.Point(length, 0)]
    path = pya.Path(points,w)
    path = pya.Path(points,w*3)
    shapes(LayerDevRecN).insert(path.simple_polygon())





def layout_waveguide_abs(cell, layer, points, w, radius):
    # create a path, then convert to a polygon waveguide with bends
    # cell: cell into which to place the waveguide
    # layer: layer to draw on
    # points: array of vertices, absolute coordinates on the current cell
    # w: waveguide width
    
    # example usage:
    # cell = Application.instance().main_window().current_view().active_cellview().cell
    # LayerSi = LayerInfo(1, 0)
    # points = [ [15, 2.75], [30, 2.75] ]  # units of microns.
    # layout_waveguide_abs(cell, LayerSi, points, 0.5, 10)

    if MODULE_NUMPY:  
      # numpy version
      points=n.array(points)  
      start_point=points[0]
      points = points - start_point  
    else:  
      # without numpy:
      start_point=[]
      start_point.append(points[0][0])
      start_point.append(points[0][1]) 
      for i in range(0,2):
        for j in range(0,len(points)):
          points[j][i] -= start_point[i]
    
    layout_waveguide_rel(cell, layer, start_point, points, w, radius)


def layout_waveguide_rel(cell, layer, start_point, points, w, radius):
    # create a path, then convert to a polygon waveguide with bends
    # cell: cell into which to place the waveguide
    # layer: layer to draw on
    # start_point: starting vertex for the waveguide
    # points: array of vertices, relative to start_point
    # w: waveguide width
    
    # example usage:
    # cell = Application.instance().main_window().current_view().active_cellview().cell
    # LayerSi = LayerInfo(1, 0)
    # points = [ [15, 2.75], [30, 2.75] ]  # units of microns.
    # layout_waveguide_rel(cell, LayerSi, [0,0], points, 0.5, 10)

    
    print("* layout_waveguide_rel(%s, %s, %s, %s)" % (cell.name, layer, w, radius) )

    ly = cell.layout() 
    dbu = cell.layout().dbu

    start_point=[start_point[0]/dbu, start_point[1]/dbu]

    a1 = []
    for p in points:
      a1.append (DPoint(float(p[0]), float(p[1])))
  
    wg_path = DPath(a1, w)

    npoints = points_per_circle(radius/dbu)
    param = { "npoints": npoints, "radius": float(radius), "path": wg_path, "layer": layer }

    pcell = ly.create_cell("ROUND_PATH", "Basic", param )

    # Configure the cell location
    trans = Trans(Point(start_point[0], start_point[1]))

    # Place the PCell
    cell.insert(CellInstArray(pcell.cell_index(), trans))



def layout_Ring(cell, layer, x, y, r, w, npoints):
    # function to produce the layout of a ring resonator
    # cell: layout cell to place the layout
    # layer: which layer to use
    # x, y: location of the origin
    # r: radius
    # w: waveguide width
    # units in microns

    # example usage.  Places the ring layout in the presently selected cell.
    # cell = Application.instance().main_window().current_view().active_cellview().cell
    # layout_Ring(cell, cell.layout().layer(TECHNOLOGY['Si']), 0, 0, 10, 0.5, 400)


    # fetch the database parameters
    dbu = cell.layout().dbu
    
    # compute the circle
    pts = []
    da = math.pi * 2 / npoints
    for i in range(0, npoints+1):
      pts.append(Point.from_dpoint(DPoint((x+(r+w/2)*math.cos(i*da))/dbu, (y+(r+w/2)*math.sin(i*da))/dbu)))
    for i in range(npoints, -1, -1):
      pts.append(Point.from_dpoint(DPoint((x+(r-w/2)*math.cos(i*da))/dbu, (y+(r-w/2)*math.sin(i*da))/dbu)))
    
    # create the shape
    cell.shapes(layer).insert(Polygon(pts))

    # end of layout_Ring


class DoubleBus_Ring(PCellDeclarationHelper):
  """
  The PCell declaration for the double bus ring resonator.
  Consists of a ring with 2 straight waveguides.
  """

  def __init__(self):

    # Important: initialize the super class
    super(DoubleBus_Ring, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("silayer", self.TypeLayer, "Si Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("s", self.TypeShape, "", default = DPoint(0, 0))
    self.param("r", self.TypeDouble, "Radius", default = 10)
    self.param("w", self.TypeDouble, "Waveguide Width", default = 0.5)
    self.param("g", self.TypeDouble, "Gap", default = 0.2)
    self.param("npoints", self.TypeInt, "Number of points", default = 500)     
    self.param("textpolygon", self.TypeInt, "Draw text polygon label? 0/1", default = 1)
    self.param("textl", self.TypeLayer, "Text Layer", default = LayerInfo(10, 0))
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "DoubleBus_Ring(R=" + ('%.3f' % self.r) + ",g=" + ('%g' % (1000*self.g)) + ")"

  def can_create_from_shape_impl(self):
    return False
    
  def produce_impl(self):
    # This is the main part of the implementation: create the layout

    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    shapes = self.cell.shapes
    
    LayerSi = self.silayer
    LayerSiN = ly.layer(LayerSi)
    TextLayerN = ly.layer(self.textl)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)

    
    # Create the ring resonator:
    layout_Ring(self.cell, LayerSiN, self.r+self.w/2, self.r+self.g+self.w, self.r, self.w, self.npoints)

    w = int(round(self.w/dbu))
    r = int(round(self.r/dbu))
    g = int(round(self.g/dbu))

 #   pcell = ly.create_cell("DirectionalCoupler_HalfRing_Straight", "SiEPIC", { "r": self.r, "w": self.w, "g": self.g, "silayer": LayerSi, "bustype": 0 } )
 #   print ("Cell: pcell: #%s" % pcell.cell_index())
 #   t = Trans(Trans.R0, 0, 0) 
 #   instance = self.cell.insert(CellInstArray(pcell.cell_index(), t))
 #   t = Trans(Trans.R180, 0, 2*r+2*g+2*w) 
 #   instance = self.cell.insert(CellInstArray(pcell.cell_index(), t))


    # Create the two waveguides
    wg1 = Box(0, -w/2, w+2*r, w/2)
    shapes(LayerSiN).insert(wg1)
    y_offset = 2*r + 2*g + 2*w
    wg2 = Box(0, y_offset-w/2, w+2*r, y_offset+w/2)
    shapes(LayerSiN).insert(wg2)

    # Create the pins, as short paths:
    pin_length = PIN_LENGTH # database units, = 0.2 microns
    
    pin = Path([Point(-pin_length/2, 0), Point(pin_length/2, 0)], w)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, 0, 0)
    text = Text ("pin1", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    pin = Path([Point(w+2*r-pin_length/2, 0), Point(w+2*r+pin_length/2, 0)],w )
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, w+2*r, 0)
    text = Text ("pin2", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    pin = Path([Point(-pin_length/2, y_offset), Point(pin_length/2, y_offset)], w)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, 0, y_offset)
    text = Text ("pin3", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    pin = Path([Point(w+2*r-pin_length/2, y_offset), Point(w+2*r+pin_length/2, y_offset)], w)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, w+2*r, y_offset)
    text = Text ("pin4", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu


    # Create the device recognition layer
    dev = Box(0, -w*3, w+2*r, y_offset+w*3 )
    shapes(LayerDevRecN).insert(dev)


    # Add a polygon text description
    if self.textpolygon:
      layout_pgtext(self.cell, self.textl, self.w, self.r+self.w, "%.3f-%g" % ( self.r, self.g), 1)

    print("Done drawing the layout for - DoubleBus_Ring: %.3f-%g" % ( self.r, self.g) )



class TestStruct_DoubleBus_Ring(PCellDeclarationHelper):
  """
  The PCell declaration for the DoubleBus_Ring test structure with grating couplers and waveguides
  """

  def __init__(self):

    # Important: initialize the super class
    super(TestStruct_DoubleBus_Ring, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("silayer", self.TypeLayer, "Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("s", self.TypeShape, "", default = DPoint(0, 0))
    self.param("r", self.TypeDouble, "Radius", default = 10)
    self.param("w", self.TypeDouble, "Waveguide Width", default = 0.5)
    self.param("g", self.TypeDouble, "Gap", default = 0.2)
    self.param("npoints", self.TypeInt, "Number of points", default = 500)     
    self.param("textpolygon", self.TypeInt, "Draw text polygon label? 0/1", default = 1)
    self.param("textlayer", self.TypeLayer, "Text Layer", default = LayerInfo(10, 0))
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "TestStruct_DoubleBus_Ring(R=" + ('%s' % self.r) + ",g=" + ('%s' % (1000*self.g)) + ")"

  def can_create_from_shape_impl(self):
    return False

    
  def produce_impl(self):
    # This is the main part of the implementation: create the layout

    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    cell = self.cell
    shapes = self.cell.shapes
    
    LayerSi = self.silayer
    LayerSiN = ly.layer(LayerSi)
    TextLayerN = ly.layer(self.textlayer)

    # Import cells from the SiEPIC GDS Library, and instantiate them

        
    # Ring resonator PCell
    r = self.r
    wg_width = self.w
    g = self.g
    y_ring = 127*3/2+r


#    pcell = ly.create_cell("DoubleBus_Ring", "SiEPIC", {"r": r, "w": wg_width, "g": g, "l": LayerSi})
#    print( "pcell: %s, %s" % (pcell.cell_index(), ly.cell_name(pcell.cell_index()) ) )
#    t = Trans(Trans.R270, 10 / dbu, y_ring / dbu) 
#    instance = cell.insert(CellInstArray(pcell.cell_index(), t))
#    print(instance.cell_index)



    lib = Library.library_by_name("SiEPIC-EBeam-dev")
    if lib == None:
      raise Exception("Unknown lib 'SiEPIC-EBeam PCells'")

    pcell_decl = lib.layout().pcell_declaration("DoubleBus_Ring");
    if pcell_decl == None:
      raise Exception("Unknown PCell 'DoubleBus_Ring'")
    param = { 
      "r": r, 
      "w": wg_width, 
      "g": g,
      "silayer": LayerSi,
      "devrec": self.devrec, 
      "pinrec": self.pinrec
    }

    pv = []
    for p in pcell_decl.get_parameters():
      if p.name in param:
        pv.append(param[p.name])
      else:
        pv.append(p.default)
    # "fake PCell code" 
    pcell = ly.create_cell("Ring")
    pcell_decl.produce(ly, [ LayerSiN ], pv, pcell)
    t = Trans(Trans.R270, 10 / dbu, y_ring / dbu) 
    instance = cell.insert(CellInstArray(pcell.cell_index(), t))


    # Grating couplers, Ports 1, 2, 3, 4 (top-down):
    GC_name = "ebeam_gc_te1550"
    GC_imported = ly.cell(GC_name)
    if GC_imported == None:
      GC_imported = ly.create_cell(GC_name, "SiEPIC-EBeam").cell_index()
    else:
      GC_imported = GC_imported.cell_index()  
    print( "Cell: GC_imported: #%s" % GC_imported )
    t = Trans(Trans.R0, 0, 0)
    instance = cell.insert(CellInstArray(GC_imported, t, Point(0,127/dbu), Point(0,0), 4, 1))
    print(instance.cell_index)

    # Label for automated measurements, laser on Port 2, detectors on Ports 1, 3, 4
    t = Trans(Trans.R0, 0, 127*2/dbu)
    text = Text ("opt_in_TE_1550_device_DoubleBusRing", t)
    shape = cell.shapes(TextLayerN).insert(text)
    shape.text_size = 3/dbu



    # Create paths for waveguides
    wg_bend_radius = 10

    # GC3 to bottom-left of ring
    points = [ [0, 127], [10,127], [10, y_ring-2*r-wg_width] ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, wg_bend_radius)

    # GC4 to bottom-right of ring
    points = [ [0, 0], [10+2*r+2*g+2*wg_width,0], [10+2*r+2*g+2*wg_width, y_ring-2*r-wg_width]  ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, 20)

    # GC2 to top-right of ring
    points = [ [10,y_ring], [10, 127*2], [0,127*2] ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, wg_bend_radius)

    # GC1 to top-left of ring
    points = [ [0, 127*3], [10+2*r+2*g+2*wg_width,127*3], [10+2*r+2*g+2*wg_width, y_ring] ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, 20)



    print( "Done drawing the layout for - TestStruct_DoubleBus_Ring: %.3f-%g" % (r, g) )






class TestStruct_DoubleBus_Ring2(PCellDeclarationHelper):
  """
  The PCell declaration for the DoubleBus_Ring test structure with grating couplers and waveguides
  """

  def __init__(self):

    # Important: initialize the super class
    super(TestStruct_DoubleBus_Ring2, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("silayer", self.TypeLayer, "Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("s", self.TypeShape, "", default = DPoint(0, 0))
    self.param("r", self.TypeDouble, "Radius", default = 10)
    self.param("w", self.TypeDouble, "Waveguide Width", default = 0.5)
    self.param("g", self.TypeDouble, "Gap", default = 0.2)
    self.param("npoints", self.TypeInt, "Number of points", default = 500)     
    self.param("textpolygon", self.TypeInt, "Draw text polygon label? 0/1", default = 1)
    self.param("textlayer", self.TypeLayer, "Text Layer", default = LayerInfo(10, 0))
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "TestStruct_DoubleBus_Ring2(R=" + ('%s' % self.r) + ",g=" + ('%s' % (1000*self.g)) + ")"

  def can_create_from_shape_impl(self):
    return False

    
  def produce_impl(self):
    # This is the main part of the implementation: create the layout

    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    cell = self.cell
    shapes = self.cell.shapes
    
    LayerSi = self.silayer
    LayerSiN = ly.layer(LayerSi)
    TextLayerN = ly.layer(self.textlayer)

    # Import cells from the SiEPIC GDS Library, and instantiate them
        
    # Ring resonator PCell
    r = self.r
    wg_width = self.w
    g = self.g
    y_ring = 127*3/2+r

    pcell = ly.create_cell("DoubleBus_Ring", "SiEPIC-EBeam PCells", {"r": r, "w": wg_width, "g": g, "silayer": LayerSi, "devrec": self.devrec, "pinrec": self.pinrec })
    print( "pcell: %s, %s" \
        % (pcell.cell_index(), ly.cell_name(pcell.cell_index()) ) )
    t = Trans(Trans.R270, 10 / dbu, y_ring / dbu) 
    instance = cell.insert(CellInstArray(pcell.cell_index(), t))
    print(instance.cell_index)


    # Grating couplers, Ports 1, 2, 3, 4 (top-down):
    GC_name = "ebeam_gc_te1550"
    GC_imported = ly.cell(GC_name)
    if GC_imported == None:
      GC_imported = ly.create_cell(GC_name, "SiEPIC-EBeam").cell_index()
    else:
      GC_imported = GC_imported.cell_index()  
    print("Cell: GC_imported: #%s" % GC_imported )
    t = Trans(Trans.R0, 0, 0)
    instance = cell.insert(CellInstArray(GC_imported, t, Point(0,127/dbu), Point(0,0), 4, 1))
    print(instance.cell_index)

    # Label for automated measurements, laser on Port 2, detectors on Ports 1, 3, 4
    t = Trans(Trans.R0, 0, 127*2/dbu)
    text = Text ("opt_in_TE_1550_device_DoubleBusRing", t)
    shape = cell.shapes(TextLayerN).insert(text)
    shape.text_size = 3/dbu

    # Create paths for waveguides
    wg_bend_radius = 10

    # GC3 to bottom-left of ring
    points = [ [0, 127], [10,127], [10, y_ring-2*r-wg_width] ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, wg_bend_radius)

    # GC4 to bottom-right of ring
    points = [ [0, 0], [10+2*r+2*g+2*wg_width,0], [10+2*r+2*g+2*wg_width, y_ring-2*r-wg_width]  ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, 20)

    # GC2 to top-right of ring
    points = [ [10,y_ring], [10, 127*2], [0,127*2] ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, wg_bend_radius)

    # GC1 to top-left of ring
    points = [ [0, 127*3], [10+2*r+2*g+2*wg_width,127*3], [10+2*r+2*g+2*wg_width, y_ring] ] 
    layout_waveguide_abs(cell, LayerSi, points, wg_width, 20)

    print( "Done drawing the layout for - TestStruct_DoubleBus_Ring2: %.3f-%g" % (r, g) )



class Waveguide_Route_simple(PCellDeclarationHelper):
  """
  The PCell declaration for a waveguide route
  """

  def __init__(self):

    # Important: initialize the super class
    super(Waveguide_Route_simple, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("layer", self.TypeLayer, "Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("path", self.TypeShape, "", default = DPath([DPoint(0,0), DPoint(10,0), DPoint(10,10)], 0.5)  )
    self.param("radius", self.TypeDouble, "Radius", default = 5)

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Waveguide_Route_simple_%s" % self.path
  
  def coerce_parameters_impl(self):
    pass

  def can_create_from_shape(self, layout, shape, layer):
    return shape.is_path()

  def transformation_from_shape(self, layout, shape, layer):
    return Trans(Trans.R0, 0,0)

  def parameters_from_shape(self, layout, shape, layer):
    self._param_values = []
    for pd in self._param_decls:
      self._param_values.append(pd.default)
    
    dbu = layout.dbu
    print("Waveguide_Route_simple.parameters_from_shape")
    print(shape.path)
    points = points_mult(path_to_Dpoints(shape.path), dbu)
    self.path = points_to_Dpath(points, shape.path.width*dbu)

    # Waveguide radius should be specified in the cell in which the Path_to_Waveguide is called
    # using a "User Properties" defined via the Cells window.
    # if missing, a dialog is presented.
    cell = shape.cell
    radius_str = cell.property("radius")  
    if radius_str:
      radius = float(radius_str)
      print("Radius taken from cell {%s} = %s" % (cell.name, radius) )
    else:
      radius = InputDialog.ask_double_ex("Bend Radius", "Enter the bend radius (microns):", 5, 1, 500, 3)
      if radius == None:
        radius = 10.0
      else:
        print("Radius taken from the InputDialog = %s; for next time, saved in cell {%s}." % (radius, cell.name) )
        cell.set_property("radius", str(radius))
    self.radius = radius
    
    return self._param_values  
        
    
  def produce_impl(self):
  
    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout

    LayerSi = self.layer
    LayerSiN = ly.layer(LayerSi)

    print("Waveguide:")
    print(self.path)
#    points = points_mult(path_to_Dpoints(self.path), 1/dbu)  # convert from microns to dbu

    points = path_to_Dpoints(self.path) 
#    w = self.path.width/dbu   # w in dbu
#    path = points_to_path(points,w)

    layout_waveguide_abs(self.cell, self.layer, points, self.path.width, self.radius)
    
    
'''
has been replaced by Waveguide in SiEPIC General library
class Waveguide_Route(PCellDeclarationHelper):
  """
  The PCell declaration for a waveguide route
  """

  def __init__(self):

    # Important: initialize the super class
    super(Waveguide_Route, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("layer", self.TypeLayer, "Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("path", self.TypeShape, "", default = DPath([DPoint(0,0), DPoint(10,0), DPoint(10,10)], 0.5)  )
    self.param("radius", self.TypeDouble, "Radius", default = 5)

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Waveguide_Route_%s" % self.path
  
  def coerce_parameters_impl(self):
    pass

  def can_create_from_shape(self, layout, shape, layer):
    return shape.is_path()

  def transformation_from_shape(self, layout, shape, layer):
#    return Trans(shape.bbox().center())
    return Trans(Trans.R0, 0,0)

  def parameters_from_shape(self, layout, shape, layer):
    shapes = self.cell.shapes
    self._param_values = []
    for pd in self._param_decls:
      self._param_values.append(pd.default)
    
    dbu = layout.dbu
    print("Waveguide_Route.parameters_from_shape")
    print(shape.path)
    points = points_mult(path_to_Dpoints(shape.path), dbu)
    self.path = points_to_Dpath(points, shape.path.width*dbu)

    # Waveguide radius should be specified in the cell in which the Path_to_Waveguide is called
    # using a "User Properties" defined via the Cells window.
    # if missing, a dialog is presented.
    cell = shape.cell
    radius_str = cell.property("radius")  
    if radius_str:
      radius = float(radius_str)
      print("Radius taken from cell {%s} = %s" % (cell.name, radius) )
    else:
      radius = InputDialog.ask_double_ex("Bend Radius", "Enter the bend radius (microns):", 5, 1, 500, 3)
      if radius == None:
        radius = 10.0
      else:
        print("Radius taken from the InputDialog = %s; for next time, saved in cell {%s}." % (radius, cell.name) )
        cell.set_property("radius", str(radius))
    self.radius = radius
    
    return self._param_values  
        
    
  def produce_impl(self):
  
    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout

    LayerSi = self.layer
    LayerSiN = ly.layer(LayerSi)

    print("Waveguide:")
    print(self.path)
    points = points_mult(path_to_Dpoints(self.path), 1/dbu)  # convert from microns to dbu
    
    # check the points to remove any co-linear points
    for i in range(len(points)-2, 0, -1):
      # if point i is colinear with its neighbours, remove it
      if check_point_in_segment(Point(*points[i-1]), Point(*points[i+1]), Point(*points[i])):
        # points.remove(i)
        pass
          
    w = self.path.width/dbu   # w in dbu
    path = points_to_path(points,w)

    # save the info on the bends we place.
    bends_pcell = []
    bends_instance = []
    
    for i in range(1,len(points)-1):
      # if point i is colinear with its neighbours, skip it
      if check_point_in_segment(Point(*points[i-1]), Point(*points[i+1]), Point(*points[i])):
        continue
        
      # Place Waveguide_Bend components at each corner:
      # determine rotation: +1 left, -1 right.
      rightvsleft_turn = ( ( angle_segments([points[i-1],points[i]], [points[i],points[i+1]])+90 ) % 360 - 90 ) / 90
      angle = ( angle_segment([points[i-1],points[i]]) ) / 90
      radius = self.radius
      seg_len = distance_xy ( points[i-1],points[i] )
      if (seg_len &lt; radius) and i==1:  # for the first bend, only 1 segment
        radius = seg_len
      if (seg_len / 2 &lt; radius) and i&gt;1:  # for the middle bends, split the segment into two
        radius = seg_len / 2
      seg_len = distance_xy ( points[i],points[i+1] )
      if (seg_len  &lt; radius) and i==len(points)-2:
        radius = seg_len 
      if (seg_len / 2 &lt; radius) and i&lt;len(points)-2:
        radius = seg_len / 2
      param = { "wg_width": self.path.width, "radius": radius, "silayer": LayerSi }
      pcell = ly.create_cell("Waveguide_Bend", "SiEPIC-EBeam PCells", param )
      trans = Trans(angle, True if rightvsleft_turn&lt;0 else False, Point(*points[i]))
      instance = self.cell.insert(CellInstArray(pcell.cell_index(), trans))
      
#      PCell_get_parameters ( pcell )
      
      # Save info on bends
      bends_pcell.append ( pcell )
      bends_instance.append (instance)

    # Place the straight waveguide segments:
    for i in range(0,len(bends_instance)-1):

      # connect p2 of bend i with p1 of bend i+1

      # bend i+1, p2:
      pins = find_PCell_pins(bends_pcell[i])
      p2 = Point(pins['pin2_x'], pins['pin2_y'] )
#      p2 = bends_pcell[i].pcell_parameters_by_name()['p2'] # Point, within the PCell's coordinates
      p2t = bends_instance[i].trans.trans(p2) # Point, transformed based on PCell's instance tranformation

      # bend i, p1:
      pins = find_PCell_pins(bends_pcell[i+1])
      p1 = Point(pins['pin1_x'], pins['pin1_y'] )
#      p1 = bends_pcell[i+1].pcell_parameters_by_name()['p1'] 
      p1t = bends_instance[i+1].trans.trans(p1) 

      # find wg_length, and rotation
      angle = ( angle_segment([points[i+1],points[i+2]]) ) / 90
      wg_length = p2t.distance(p1t) # Path([p2, p1], w).length()
      if wg_length &gt; 0:
        # place the waveguide:      
        param = { "wg_width": w, "wg_length": wg_length, "layer": LayerSi }
        pcell = ly.create_cell("Waveguide_Straight", "SiEPIC-EBeam PCells", param )
        p3 = Point ((p2t.x+p1t.x)/2, (p2t.y+p1t.y)/2) # midpoint of p2t p1t
        trans = Trans(angle, False, p3)
        self.cell.insert(CellInstArray(pcell.cell_index(), trans))      
        print("straight wg mid-section inst: %s, %s, %s, [%s];   bend: %s, %s, p2 %s" % (i, angle, wg_length, p3, bends_instance[i], bends_pcell[i], p2) )

    # put in the straight segment at the beginning of the path
    if len(bends_pcell) &gt; 0:
      pins = find_PCell_pins(bends_pcell[0])
      p1 = Point(pins['pin1_x'], pins['pin1_y'] )
      p1t = bends_instance[0].trans.trans(p1) 
      p0 = Point(*points[0])
      angle = ( angle_segment([points[0],points[1]]) ) / 90
      wg_length = p0.distance(p1t) 
      if wg_length &gt; 0:
        # place the waveguide:      
        p3 = Point ((p0.x+p1t.x)/2, (p0.y+p1t.y)/2) # midpoint
        param = { "wg_width": w, "wg_length": wg_length, "layer": LayerSi }
        pcell = ly.create_cell("Waveguide_Straight", "SiEPIC-EBeam PCells", param )
        trans = Trans(angle, False, p3)
        self.cell.insert(CellInstArray(pcell.cell_index(), trans))      
        print("straight wg end-section inst: %s, %s, %s, [%s]; " % (i, angle, wg_length, p3) )
        
      # put in the straight segment at the end of the path
      i=len(bends_instance)-2
      pins = find_PCell_pins(bends_pcell[i+1])
      p2 = Point(pins['pin2_x'], pins['pin2_y'] )
      p2t = bends_instance[i+1].trans.trans(p2) 
      p0 = Point(*points[i+3])
      angle = ( angle_segment([points[i+2],points[i+3]]) ) / 90
      wg_length = p0.distance(p2t) 
      if wg_length &gt; 0:
        # place the waveguide:      
        p3 = Point ((p0.x+p2t.x)/2, (p0.y+p2t.y)/2) # midpoint
        param = { "wg_width": w, "wg_length": wg_length, "layer": LayerSi }
        pcell = ly.create_cell("Waveguide_Straight", "SiEPIC-EBeam PCells", param )
        trans = Trans(angle, False, p3)
        self.cell.insert(CellInstArray(pcell.cell_index(), trans))      
        print("straight wg end-section inst: %s, %s, %s, [%s]; " % (i, angle, wg_length, p3) )
    else:
      # just a straight section:
        p1 = Point(*points[0])
        p2 = Point(*points[len(points)-1])
        wg_length = p1.distance(p2) 
        angle = ( angle_segment([points[0],points[len(points)-1]]) ) / 90
        p3 = Point ((p1.x+p2.x)/2, (p1.y+p2.y)/2) # midpoint
        param = { "wg_width": w, "wg_length": wg_length, "layer": LayerSi }
        pcell = ly.create_cell("Waveguide_Straight", "SiEPIC-EBeam PCells", param )
        trans = Trans(angle, False, p3)
        self.cell.insert(CellInstArray(pcell.cell_index(), trans))      
        print("straight wg end-section inst:  %s, %s, [%s]; " % (angle, wg_length, p3) )

'''


class Waveguide_Arc(PCellDeclarationHelper):
  """
  The PCell declaration for the waveguide arc.
  
  Author: Mustafa Hammood     mustafa@ece.ubc.ca
  """

  def __init__(self):

    # Important: initialize the super class
    super(Waveguide_Arc, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("silayer", self.TypeLayer, "Si Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("radius", self.TypeDouble, "Radius", default = 10)
    self.param("wg_width", self.TypeDouble, "Waveguide Width", default = 0.5)
    self.param("start_angle", self.TypeDouble, "Start Angle", default = 0)
    self.param("stop_angle", self.TypeDouble, "Stop Angle", default = 45)
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
    # hidden parameters, can be used to query this component:
    self.param("p1", self.TypeShape, "DPoint location of pin1", default = Point(-10000, 0), hidden = True, readonly = True)
    self.param("p2", self.TypeShape, "DPoint location of pin2", default = Point(0, 10000), hidden = True, readonly = True)
    

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Waveguide_Arc(R=" + ('%.3f' % self.radius) + ")"

  def produce(self, layout, layers, parameters, cell):
    """
    coerce parameters (make consistent)
    """
    self._layers = layers
    self.cell = cell
    self._param_values = parameters
    self.layout = layout


    # cell: layout cell to place the layout
    # LayerSiN: which layer to use
    # r: radius
    # w: waveguide width
    # start_angle: starting angle of the arc
    # stop_agnle: stopping angle of the arc
    # length units in dbu

    from math import pi, cos, sin
    from SiEPIC.utils import arc_wg
    
    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    
    LayerSi = self.silayer
    LayerSiN = self.silayer_layer
#    LayerSiN = ly.layer(LayerSi)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)
    
    from SiEPIC.extend import to_itype
    w = to_itype(self.wg_width,dbu)
    r =  to_itype(self.radius,dbu)
    start_angle = self.start_angle
    stop_angle = self.stop_angle
    
    if start_angle &gt; stop_angle:
      start_angle = self.stop_angle
      stop_angle = self.start_angle
    
    deg_to_rad = math.pi / 180.0
    
    
    # draw the arc
    x = 0
    y = 0
    
    
    from SiEPIC._globals import PIN_LENGTH as pin_length
    
    self.cell.shapes(LayerSiN).insert(arc_wg(r, w, start_angle, stop_angle))
    # Create the pins, as short paths:

    # Pin on the right side:
    x = r*math.cos( start_angle * deg_to_rad ) 
    y = r*math.sin( start_angle * deg_to_rad )
    
    x_pin = math.cos( (90 - start_angle)*deg_to_rad ) *pin_length/2
    y_pin = math.sin( (90 - start_angle)*deg_to_rad ) *pin_length/2
    
    p2 = [Point(x-x_pin, y+y_pin), Point(x+x_pin, y-y_pin)]
    p2c = Point(x, y)
    self.set_p2 = p2c
    self.p2 = p2c
    pin = Path(p2, w)
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, x, y)
    text = Text ("pin2", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu


    # Pin on the left side:
    x = round(r*math.cos( stop_angle * deg_to_rad ))
    y = round(r*math.sin( stop_angle * deg_to_rad ))
    
    x_pin = math.cos( (90.0 - stop_angle)*deg_to_rad ) *pin_length/2
    y_pin = math.sin( (90.0 - stop_angle)*deg_to_rad ) *pin_length/2
    
    p1 = [Point(x+x_pin, y-y_pin), Point(x-x_pin, y+y_pin)]
    p1c = Point(x,y)
    self.set_p1 = p1c
    self.p1 = p1c
    pin = Path(p1, w)
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, x, y)
    text = Text ("pin1", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    
    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
    x = 0
    y = 0
    #layout_arc_wg_dbu(self.cell, LayerDevRecN, x, y, r, w*3, start_angle, stop_angle)
    self.cell.shapes(LayerDevRecN).insert(arc_wg(r, w*3, start_angle, stop_angle))

class Bent_Coupled_Half_Ring(PCellDeclarationHelper):
  """
  The PCell declaration for the bent-coupled half ring resonator pcell
  
  Author: Mustafa Hammood     mustafa@ece.ubc.ca
  """

  def __init__(self):

    # Important: initialize the super class
    super(Bent_Coupled_Half_Ring, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("silayer", self.TypeLayer, "Si Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("radius", self.TypeDouble, "Radius", default = 10)
    self.param("bus_radius", self.TypeDouble, "Bus Radius", default = 5)
    self.param("gap", self.TypeDouble, "Gap", default = 0.2)
    self.param("bus_width", self.TypeDouble, "Bus Width", default = 0.5)
    self.param("ring_width", self.TypeDouble, "Ring Width", default = 0.5)
    self.param("bend_angle", self.TypeDouble, "Bend angle", default = 45)
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
    # hidden parameters, can be used to query this component:
    self.param("p1", self.TypeShape, "DPoint location of pin1", default = Point(-10000, 0), hidden = True, readonly = True)
    self.param("p2", self.TypeShape, "DPoint location of pin2", default = Point(0, 10000), hidden = True, readonly = True)
    

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Bent_Coupler(R=" + ('%.3f' % self.radius) + ")"


  def produce(self, layout, layers, parameters, cell):
    """
    coerce parameters (make consistent)
    """
    self._layers = layers
    self.cell = cell
    self._param_values = parameters
    self.layout = layout


    # cell: layout cell to place the layout
    # LayerSiN: which layer to use
    # r: radius
    # w: waveguide width
    # length units in dbu

    from math import pi, cos, sin
    from SiEPIC.utils import arc_wg_xy
    from SiEPIC._globals import PIN_LENGTH as pin_length
    from SiEPIC.extend import to_itype
    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    
    LayerSi = self.silayer
    LayerSiN = self.silayer_layer
#    LayerSiN = ly.layer(LayerSi)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)
    
  

      
    w_bus = to_itype(self.bus_width,dbu)
    w_ring = to_itype(self.ring_width,dbu)
    r = to_itype(self.radius,dbu)
    r_bus = to_itype(self.bus_radius,dbu)
    bend_angle = int(round(self.bend_angle))
    gap =to_itype(self.gap,dbu)
        
    #**********************
    # Draw the ring waveguide
    #**********************

      
    
    x = 0
    y = 0
    
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(x, y, r, w_ring, 0, 180))

    # Create the pins, as short paths:
    
    # Pin on the bottom left side:
    p3 = [Point(x-r, pin_length/2 +y), Point(x-r, -pin_length/2 +y)]
    p3c = Point(x-r, y)
    self.set_p3 = p3c
    self.p3 = p3c
    pin = Path(p3, w_ring)
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, x-r, y)
    text = Text ("pin3", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    # Pin on the bottom right side:
    p4 = [Point(x+r, y+pin_length/2), Point(x+r,y-pin_length/2)]
    p4c = Point(x+r,y)
    self.set_p4 = p4c
    self.p4 = p4c
    pin = Path(p4, w_ring)
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, x+r, y)
    text = Text ("pin4", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu
    
    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides. 
    self.cell.shapes(LayerDevRecN).insert(arc_wg_xy(x, y, r, w_ring*3, 0, 180))
    
    #**********************
    # Draw the bus waveguide (figure out how to call the existing class maybe??)
    #**********************
    
    r_original = to_itype(self.radius,dbu)
    
    
    
    r = r + gap + w_ring/2 + w_bus/2
    
      # number of points per circle:
     # npoints = int(points_per_circle(r))
      # increment, in radians, for each point:
      #da = 2 * pi / npoints  
      
    # draw the first arc
    x = round(-r*math.sin(bend_angle * math.pi/180) - r_bus*math.sin(bend_angle * math.pi/180) )
    y = round(r*math.cos(bend_angle * math.pi/180) + r_bus*math.cos(bend_angle * math.pi/180) )
    
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(x, y, r_bus, w_bus, 270, 270+bend_angle))

    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
    self.cell.shapes(LayerDevRecN).insert(arc_wg_xy(x, y, r_bus, w_bus*3, 270, 270+bend_angle))
    
        
    # draw the second arc
    r = to_itype(self.radius,dbu)
    x = 0
    y = 0
    
    r = r + gap + w_ring/2 + w_bus/2
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(x, y, r, w_bus, 90-bend_angle, 90+bend_angle))
    
    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
    self.cell.shapes(LayerDevRecN).insert(arc_wg_xy(x, y, r, w_bus*3, 90-bend_angle, 90+bend_angle))
    
    
    # draw the third arc
    
    x = round(r*math.sin(bend_angle * math.pi/180) + r_bus*math.sin(bend_angle * math.pi/180) )
    y = round(r*math.cos(bend_angle * math.pi/180) + r_bus*math.cos(bend_angle * math.pi/180))
    
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(x, y, r_bus, w_bus, 270-bend_angle, 270))

    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
    self.cell.shapes(LayerDevRecN).insert(arc_wg_xy(x, y, r_bus, w_bus*3, 270-bend_angle, 270))
    

    r = to_itype(self.radius,dbu)
    r = r + gap + w_ring/2 + w_bus/2
    # Pin on the left side:
    x = round(-r*math.sin(bend_angle * math.pi/180) - r_bus*math.sin(bend_angle * math.pi/180)) 
    y = round(r*math.cos(bend_angle * math.pi/180) + r_bus*math.cos(bend_angle * math.pi/180) -r_bus)
    
    p2 = [Point(x+pin_length/2, y), Point(x-pin_length/2, y)]
    p2c = Point(x, y)
    self.set_p2 = p2c
    self.p2 = p2c
    pin = Path(p2, w_bus)
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, x, y)
    text = Text ("pin2", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    # Pin on the right side:
    p1 = [Point(-x-pin_length/2,y), Point(-x+pin_length/2,y)]
    p1c = Point(x,-r)
    self.set_p1 = p1c
    self.p1 = p1c
    pin = Path(p1, w_bus)
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, -x, y)
    text = Text ("pin1", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu
    

    
    
class Bent_Contra_DC(PCellDeclarationHelper):
  """
  The PCell declaration for the bent-CDC half ring resonator pcell
  
  Author: Mustafa Hammood     mustafa@ece.ubc.ca
  """

  def __init__(self):

    # Important: initialize the super class
    super(Bent_Contra_DC, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("silayer", self.TypeLayer, "Si Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("silayer_gratings", self.TypeLayer, "Si Gratings Layer", default = [TECHNOLOGY['31_Si_p6nm']])
    self.param("radius", self.TypeDouble, "Radius (um)", default = 25)
    self.param("gap", self.TypeDouble, "Gap (um)", default = 0.28)
    self.param("bus_width", self.TypeDouble, "Bus Width (um)", default = 0.45)
    self.param("ring_width", self.TypeDouble, "Ring Width (um)", default = 0.55)
    
    self.param("period", self.TypeDouble, "Gratings Period (nm)", default = 318)
    self.param("deltaWB", self.TypeDouble, "Bus Corrugation Width (um)", default = 0.04)
    self.param("deltaWR", self.TypeDouble, "Ring Corrugation Width (um)", default = 0.05)
    self.param("gamma", self.TypeDouble, "N (number of corrugations)", default = 135)
    
    self.param("busBend", self.TypeDouble, "Bus-to-straight bend raidus", default = 5)
    
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
    # hidden parameters, can be used to query this component:
    self.param("p1", self.TypeShape, "DPoint location of pin1", default = Point(-10000, 0), hidden = True, readonly = True)
    self.param("p2", self.TypeShape, "DPoint location of pin2", default = Point(0, 10000), hidden = True, readonly = True)
    

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Bent_CDC(R=" + ('%.3f' % self.radius) + ")"

  def produce(self, layout, layers, parameters, cell):
    """
    coerce parameters (make consistent)
    """
    self._layers = layers
    self.cell = cell
    self._param_values = parameters
    self.layout = layout


    # cell: layout cell to place the layout
    # LayerSiN: which layer to use
    # r: radius
    # w: waveguide width
    # length units in dbu

    from math import pi, cos, sin
    from SiEPIC.utils import arc_wg, arc_wg_xy
    from SiEPIC._globals import PIN_LENGTH
    
    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    
    LayerSi = self.silayer
    LayerSiN_gratings = self.silayer_gratings_layer
    LayerSiN = self.silayer_layer
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)
    
    from SiEPIC.extend import to_itype
    
    w_bus = to_itype(self.bus_width,dbu)
    w_ring = to_itype(self.ring_width,dbu)
    w = w_ring
    r = int(round(self.radius/dbu))
    gap = int(round(self.gap/dbu))
    period = self.period
    deltaWR = int(round(self.deltaWR/dbu))
    N = int(self.gamma)
    deltaWB = int(round(self.deltaWB/dbu))
    busBendR = int(round(self.busBend/dbu))

    
    # Center of everything
    x = 0
    y = 0

    # Angle of CDC portion, also bend angle!
    periodAngle = (180/pi) * (period/2) / (r + w_ring/2 + gap/2) 
    
    # Bend angle
    bendAngle = (180/pi) * (N*period/2) / (r + w_ring/2 + gap/2) 
    
    # Bend radius of bus
    rBus = r + gap + w_bus/2 +w_ring/2
      
    N_input = N;
    # Normalized number of corrugations to periodAngle
    N = N*periodAngle*2;

    # Convention:   Set A is the CDC portion that is not offsetted, set B is offsetted by corrugation width
      
    # Ring CDCs (set A)
    ii = periodAngle*2
    while ii &lt; N+periodAngle*1.5:
      self.cell.shapes(LayerSiN_gratings).insert(arc_wg_xy(x,y, r-deltaWR/2, w_ring, 90+bendAngle-ii, 90+bendAngle-ii-periodAngle))
      ii = ii+periodAngle
      ii = ii+periodAngle
      
    # Ring CDCs (set B)
    ii = periodAngle
    while ii &lt; N:
      self.cell.shapes(LayerSiN_gratings).insert(arc_wg_xy(x,y, r+deltaWR/2, w_ring, 90+bendAngle-ii, 90+bendAngle-ii-periodAngle))
      ii = ii+periodAngle
      ii = ii+periodAngle


    # Bus CDCs (set A)
    ii = periodAngle
    while ii &lt; N:
      self.cell.shapes(LayerSiN_gratings).insert(arc_wg_xy(x,y, rBus-deltaWB/2, w_bus, 90+bendAngle-ii, 90+bendAngle-ii-periodAngle))
      ii = ii+periodAngle
      ii = ii+periodAngle

    # Bus CDCs (set B)
    ii = periodAngle*2
    while ii &lt; N+periodAngle*1.5:
      self.cell.shapes(LayerSiN_gratings).insert(arc_wg_xy(x,y, rBus+deltaWB/2, w_bus, 90+bendAngle-ii, 90+bendAngle-ii-periodAngle))
      ii = ii+periodAngle
      ii = ii+periodAngle

    # Ring non-CDC left
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y, r, w_ring, 180-(90-bendAngle), 180))
    
    # Ring non-CDC right
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(x,y, r, w_ring, 0, 90-bendAngle))
    
    bendAngleRad = (pi/180) * bendAngle
    # Draw Bus non-CDC Waveguide
    y_center = rBus * cos(bendAngleRad) + busBendR * cos(bendAngleRad);
    x_center = rBus * sin(bendAngleRad) + busBendR * sin(bendAngleRad);
    
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(x_center,y_center, busBendR, w_bus, 270-bendAngle,270))
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(-x_center,y_center, busBendR, w_bus, 270, 270-bendAngle))
    
    # Create the pins, as short paths:
    from SiEPIC._globals import PIN_LENGTH as pin_length
    
    # Pin on the right side:
    y_center = rBus * cos(bendAngleRad) + busBendR * cos(bendAngleRad) - busBendR;
    p2 = [Point(-pin_length/2 +x_center, y_center), Point(pin_length/2 +x_center, y_center)]
    p2c = Point(x_center, y_center)
    self.set_p2 = p2c
    self.p2 = p2c
    pin = Path(p2, w_bus)
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, x_center, y_center)
    text = Text ("pin2", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu
    
    # Pin on the left side:
    x_center = -x_center
    p1 = [Point(pin_length/2 +x_center, y_center), Point(-pin_length/2 +x_center, y_center)]
    p1c = Point(x_center, y_center)
    self.set_p1 = p1c
    self.p1 = p1c
    pin = Path(p1, w_bus)
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, x_center, y_center)
    text = Text ("pin1", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu
    
    
    # Pin on the bottom left side:
    p3 = [Point(x-r, pin_length/2 +y), Point(x-r, -pin_length/2 +y)]
    p3c = Point(x-r, y)
    self.set_p3 = p3c
    self.p3 = p3c
    pin = Path(p3, w_ring)
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, x-r, y)
    text = Text ("pin3", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    # Pin on the bottom right side:
    p4 = [Point(x+r, y+pin_length/2), Point(x+r,y-pin_length/2)]
    p4c = Point(x+r,y)
    self.set_p4 = p4c
    self.p4 = p4c
    pin = Path(p4, w_ring)
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, x+r, y)
    text = Text ("pin4", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu
    
    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
    self.cell.shapes(LayerDevRecN).insert(arc_wg_xy(x ,y, r+gap, w*5, 0, 180))
    
    
    
class Bezier_Bend(PCellDeclarationHelper):
  """
  Input: bezier number, effective radius, waveguide width, layers
  draws a 90 degree bezier bend with a given bezier factor
  Usage: instantiate, and use transformations (rotation)
  
  This implementation is Python translation of the 90 degree Bezier bend ample script for Mentor Graphics Pyxis
    by Jonas Flueckiger and Lukas Chrostowski's
    influenced by www.tinaja.com/glib/cubemath.pdf implementation
    
  Author: Mustafa Hammood     mustafa@ece.ubc.ca
  """

  def __init__(self):

    # Important: initialize the super class
    super(Bezier_Bend, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("bezier_num", self.TypeDouble, "Bezier factor", default = 25)     
    self.param("eff_r", self.TypeDouble, "Effective bend radius (microns)", default = 5)
    self.param("wg_width", self.TypeDouble, "Waveguide width (microns)", default = 0.500)     
    self.param("layer", self.TypeLayer, "Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
#    self.param("textl", self.TypeLayer, "Text Layer", default = LayerInfo(10, 0))

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Bezier_Number_%.3f-%.3f" % (self.bezier_num/1000, self.wg_width/1000)
  
  def coerce_parameters_impl(self):
    pass

  def can_create_from_shape(self, layout, shape, layer):
    return False
    
  def produce_impl(self):
  
    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout

    LayerSi = self.layer
    LayerSiN = ly.layer(LayerSi)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)

    
    

    from SiEPIC.utils import arc_bezier
    from SiEPIC._globals import PIN_LENGTH as pin_length
    from SiEPIC.extend import to_itype
    wg_width = self.wg_width
    w = self.wg_width/dbu

    r = self.eff_r/dbu
    bezier = self.bezier_num/100
    
    x = -r
    y = r
    
    points = arc_bezier(r, 270, 360, bezier)
    a = pya.Path(points, w).simple_polygon()
    d= [each for each in a.each_point()]
    pt_idx = int(len(d)/2)
    ptA = d[pt_idx]
    ptB = d[pt_idx+1]
    print(pt_idx)
    print(d)
    if(abs(ptA.x-ptB.x)*dbu  == wg_width):
      new_y = (ptA.y+ptB.y)/2
      d[pt_idx].y = new_y
      d[pt_idx+1].y = new_y
    elif(abs(ptA.y-ptB.y)*dbu  == wg_width):
      new_x = (ptA.x + ptB.x)/2
      d[pt_idx].x = new_x
      d[pt_idx+1].x = new_x
    print(d)
  
    self.cell.shapes(LayerSiN).insert(Polygon(d))
    
    # Create the pins, as short paths:
    w = int(round(self.wg_width/dbu))
    r = int(round(self.eff_r/dbu))
    x = r
    y = r
    
    # Pin on the top side:
    p2 = [Point(0, y-pin_length/2), Point(0, y+pin_length/2)]
    p2c = Point(x, y)
    self.set_p2 = p2c
    self.p2 = p2c
    pin = Path(p2, w)
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, 0, y)
    text = Text ("pin2", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    x = 0
    y = 0
    # Pin on the left side:
    p1 = [Point(pin_length/2-r,0), Point(-pin_length/2-r,0)]
    p1c = Point(x,0)
    self.set_p1 = p1c
    self.p1 = p1c
    pin = Path(p1, w)
    self.cell.shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, -r, 0)
    text = Text ("pin1", t)
    shape = self.cell.shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
    points = arc_bezier(r, 270, 360, bezier)
    self.cell.shapes(LayerDevRecN).insert(pya.Path(points, w*3))



class Tapered_Ring(PCellDeclarationHelper):
  """
  The PCell declaration for the tapered ring.
  Author: Mustafa Hammood     mustafa@ece.ubc.ca
  """

  def __init__(self):

    # Important: initialize the super class
    super(Tapered_Ring, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("w_top", self.TypeDouble, "Top width", default = .5)
    self.param("w_bot", self.TypeDouble, "Bottom width (&gt;Top Width)", default = 2)
    self.param("radius", self.TypeDouble, "Radius", default = 10)
    self.param("LayerSi", self.TypeLayer, "Si Layer", default = [TECHNOLOGY['Waveguide']])
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])


  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Tapered_Ring(R=" + ('%.3f-%.3f' % (self.radius,self.w_bot) ) + ")"

  def can_create_from_shape(self, layout, shape, layer):
    return False


  def produce_impl(self):   
    import pya
    from operator import xor
    from math import pi, cos, sin
    
    #fetch parameters
    
    dbu = self.layout.dbu
    ly = self.layout
    shapes = self.cell.shapes

    #Layers definitions
    LayerSi = self.layer
    LayerSiN = ly.layer(self.LayerSi)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)
    #LayerTextN = ly.layer(LayerText)
    
    # cell: layout cell to place the layout
    # LayerSiN: which layer to use
    # x, y: location of the origin
    # r: radius
    # w: waveguide width
    # length units in dbu

    x = 0
    w_top = self.w_top/dbu
    r = self.radius/dbu    
   
    w_bot = self.w_bot/dbu
    
    
    deltaW = w_bot - w_top
    
    nptsFactor = 12
    
    
    # function to generate points to create circle
    def circle(x,w_top,r):
      npts = 32*nptsFactor
      theta =  2*math.pi / npts # increment, in radians
      pts = []
      for i in range(0, npts):
        pts.append(Point.from_dpoint(DPoint((x+r*math.cos(i*theta))/1, (w_top+r*math.sin(i*theta))/1)))
      return pts
  
    # function to generate points to create innercircle
    def inner_circle(x,w_top,r):
      npts = 32*nptsFactor
      theta =  2*math.pi / npts # increment, in radians
      pts = []
      for i in range(0, npts):
        pts.append(Point.from_dpoint(DPoint((x+r*math.cos(i*theta))/1, (w_top+r*math.sin(i*theta))/1)))
      return pts
     
  
    # Outer circle
    x = 0
    y = 0
    r_out = r+w_top/2
    ring = Region()
    ring_cell = circle(0,0,r_out)
    ring_poly = Polygon(ring_cell)  
    #ring_t = ring_poly.transformed(Trans(x,y))
    ring.insert(ring_poly)
    
    
    # Inner erasing circle  
    r_in = r - (w_top)/2 - deltaW/2
    x = 0
    y = -deltaW/2
    # Inner Circle 
    hole = Region()
    hole_cell = inner_circle(x,y,r_in)
    hole_poly = Polygon(hole_cell)  
    #hole_t = hole_poly.transformed(Trans(x,y))
    hole.insert(hole_poly)           
    
    # perform inversion:
    phc = ring - hole
    self.cell.shapes(LayerSiN).insert(phc)
    # inversion can also be done by performing the XOR function
    # upper_poly = xor(Region(Polygon(circleu_pts)),Region(Polygon(rectu_pts)))
    
    return "Tapered_Ring(R=" + ('%.3f-%.3f' % (r,w_bot) ) + ")"



class DirectionalCoupler_SeriesRings(PCellDeclarationHelper):
  """
  The PCell declaration for the DirectionalCoupler_SeriesRings.

  """

  def __init__(self):

    # Important: initialize the super class
    super(DirectionalCoupler_SeriesRings, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("silayer", self.TypeLayer, "Si Layer", default = TECHNOLOGY['Si'])
    self.param("r2", self.TypeDouble, "Radius of Upper Ring", default = 3)
    self.param("r1", self.TypeDouble, "Radius of Lower Ring", default = 3)
    self.param("w", self.TypeDouble, "Waveguide Width", default = 0.5)
    self.param("g", self.TypeDouble, "Gap", default = 0.2)
    self.param("Lc", self.TypeDouble, "Coupler Length", default = 0.0)
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
    self.param("textl", self.TypeLayer, "Text Layer", default = LayerInfo(10, 0))

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "DirectionalCoupler_SeriesRings(R1=" + ('%.3f' % self.r1)+ ",R2=" + ('%.3f' % self.r2) + ",g=" + ('%g' % (1000*self.g)) + ")"

  def can_create_from_shape_impl(self):
    return False
    
  def produce_impl(self):
    # This is the main part of the implementation: create the layout

    from math import pi, cos, sin
    from SiEPIC._globals import PIN_LENGTH as pin_length
    from SiEPIC.utils import arc_wg_xy

    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    shapes = self.cell.shapes
    
    LayerSi = self.silayer
    LayerSiN = ly.layer(LayerSi)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)
    TextLayerN = ly.layer(self.textl)

    
    w = int(round( self.w/dbu))
    r1 = int(round( self.r1/dbu))
    r2 = int(round( self.r2/dbu))
    g = int(round( self.g/dbu))
    Lc = int(round( self.Lc/dbu))

    # draw the half-circle
    x = 0
    y = r1+r2+g+w
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(x-Lc/2, y, r2, w, 180, 270))
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(x+Lc/2, y, r2, w, 270, 360))
    
    # Create the pins, as short paths:
    
    # Pins on the top side:
    pin = Path([Point(-r2-Lc/2, y-pin_length/2), Point(-r2-Lc/2, y+pin_length/2)], w)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, -r2-Lc/2, y)
    text = Text ("pin2", t)
    shape =  shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    pin = Path([Point(r2+Lc/2, y-pin_length/2), Point(r2+Lc/2, y+pin_length/2)], w)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, r2+Lc/2, y)
    text = Text ("pin4", t)
    shape =  shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    if Lc &gt; 0:
      wg1 = Box(-Lc/2,w + w/2+ g+ r1 , Lc/2, w/2 + g+ r1)
      shapes(LayerSiN).insert(wg1)


    y = 0
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(x-Lc/2, y, r1, w, 90, 180))
    self.cell.shapes(LayerSiN).insert(arc_wg_xy(x+Lc/2, y, r1, w, 0, 90))
    
    # Pins on the lower side:
    pin = Path([Point(-r1-Lc/2, y+pin_length/2), Point(-r1-Lc/2, y-pin_length/2)], w)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, -r1-Lc/2, y)
    text = Text ("pin1", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    pin = Path([Point(r1+Lc/2, y+pin_length/2), Point(r1+Lc/2, y-pin_length/2)], w)
    shapes(LayerPinRecN).insert(pin)
    t = Trans(Trans.R0, r1+Lc/2, y)
    text = Text ("pin3", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    if Lc &gt; 0:
      wg1 = Box(-Lc/2,  r1 -w/2, Lc/2, w/2 + r1)
      shapes(LayerSiN).insert(wg1)

    if(r1&gt;r2):
      r = r1
    else: 
      r = r2
    
    
    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
    dev = Box(-r-w/2-w-Lc/2,r1+r2+g+w, r+w/2+w+Lc/2, y )
    shapes(LayerDevRecN).insert(dev)


    # Compact model information
    t = Trans(Trans.R0, ((r1+r2)/2)/4, 0)
    text = Text ("Lumerical_INTERCONNECT_library=Design kits/ebeam_v1.2", t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size =  r*0.017
    t = Trans(Trans.R0, ((r1+r2)/2)/4, ((r1+r2)/2)/4)
    text = Text ('Component=ebeam_dc_seriesrings', t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size =  r*0.017
    t = Trans(Trans.R0, ((r1+r2)/2)/4, ((r1+r2)/2)/2)
  #  text = Text ('Spice_param:wg_width=%.3fu gap="%s" radius="%s"'% ( w, g,int( r)), t)
    text = Text ('Spice_param:wg_width=%.3fu gap=%.3fu radius1=%.3fu radius2=%.3fu'% ( self.w, self.g,int( self.r1), int(self.r2)), t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size =  r*0.017

    print("Done drawing the layout for - DirectionalCoupler_SeriesRings: %.3f-%.3f-%g" % ( self.r1, self.r2, self.g) )



class ebeam_bragg_apodized(PCellDeclarationHelper):
  """
  Author:   Mustafa Hammood 
                Mustafa@ece.ubc.ca
  """

  def __init__(self):

    # Important: initialize the super class
    super(ebeam_bragg_apodized, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("number_of_periods", self.TypeInt, "Number of grating periods", default = 300)     
    self.param("grating_period", self.TypeDouble, "Grating period (microns)", default = 0.317)     
    self.param("corrugation_width", self.TypeDouble, "Corrugration width (microns)", default = 0.05)     
    self.param("misalignment", self.TypeDouble, "Grating misalignment (microns)", default = 0.0)     
    self.param("sinusoidal", self.TypeBoolean, "Grating Type (Rectangular=False, Sinusoidal=True)", default = False)     
    self.param("wg_width", self.TypeDouble, "Waveguide width", default = 0.5)     
    self.param("index", self.TypeDouble, "Gaussian Index", default = 3)
    self.param("layer", self.TypeLayer, "Layer", default = TECHNOLOGY['Waveguide'])
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
#    self.param("textl", self.TypeLayer, "Text Layer", default = LayerInfo(10, 0))

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "ebeam_bragg_apodized_%s-%.3f-%.3f-%.3f" % \
    (self.number_of_periods, self.grating_period, self.corrugation_width, self.misalignment)
  
  def coerce_parameters_impl(self):
    pass

  def can_create_from_shape(self, layout, shape, layer):
    return False
    
  def produce_impl(self):
  
    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    shapes = self.cell.shapes

    LayerSi = self.layer
    LayerSiN = ly.layer(LayerSi)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)

    from SiEPIC.extend import to_itype
    
    # Draw the Bragg grating:
    box_width = int(round(self.grating_period/2/dbu))
    grating_period = int(round(self.grating_period/dbu))
    w = to_itype(self.wg_width,dbu)
    GaussianIndex = self.index
    half_w = w/2
    half_corrugation_w = int(round(self.corrugation_width/2/dbu))
    misalignment = int(round(self.misalignment/dbu))
    N = self.number_of_periods
    if self.sinusoidal:
      npoints_sin = 40
      for i in range(0,self.number_of_periods):
        x = (round((i * self.grating_period)/dbu))
        profileFunction = math.exp( -0.5*(2*GaussianIndex*(i-N/2)/(N))**2 )
        profile = int(round(self.corrugation_width/2/dbu))*profileFunction;
        box1 = Box(x, 0, x + box_width, half_w+profile)
        pts1 = [Point(x,0)]
        pts3 = [Point(x + misalignment,0)]
        for i1 in range(0,npoints_sin+1):
          x1 = i1 * 2* math.pi / npoints_sin
          y1 = round(profile*math.sin(x1))
          x1 = round(x1/2/math.pi*grating_period)
#          print("x: %s, y: %s" % (x1,y1))
          pts1.append( Point(x + x1,half_w+y1 ) )
          pts3.append( Point(x + misalignment + x1,-half_w-y1 ) )
        pts1.append( Point(x + grating_period, 0) )
        pts3.append( Point(x + grating_period + misalignment, 0) )
        shapes(LayerSiN).insert(Polygon(pts1))
        shapes(LayerSiN).insert(Polygon(pts3))
      length = x + grating_period + misalignment
      if misalignment &gt; 0:
        # extra piece at the end:
        box2 = Box(x + grating_period, 0, length, half_w)
        shapes(LayerSiN).insert(box2)
        # extra piece at the beginning:
        box3 = Box(0, 0, misalignment, -half_w)
        shapes(LayerSiN).insert(box3)

    else:
    
      
      
      for i in range(0,self.number_of_periods):
        x = int(round((i * self.grating_period)/dbu))
        
        profileFunction = math.exp( -0.5*(2*GaussianIndex*(i-N/2)/(N))**2 )
        profile = int(round(self.corrugation_width/2/dbu))*profileFunction;
        box1 = Box(x, 0, x + box_width, half_w+profile)
        box2 = Box(x + box_width, 0, x + grating_period, half_w-profile)
        box3 = Box(x + misalignment, 0, x + box_width + misalignment, -half_w-profile)
        box4 = Box(x + box_width + misalignment, 0, x + grating_period + misalignment, -half_w+profile)
        shapes(LayerSiN).insert(box1)
        shapes(LayerSiN).insert(box2)
        shapes(LayerSiN).insert(box3)
        shapes(LayerSiN).insert(box4)
      length = x + grating_period + misalignment
      if misalignment &gt; 0:
        # extra piece at the end:
        box2 = Box(x + grating_period, 0, length, half_w)
        shapes(LayerSiN).insert(box2)
        # extra piece at the beginning:
        box3 = Box(0, 0, misalignment, -half_w)
        shapes(LayerSiN).insert(box3)

    
    # Create the pins on the waveguides, as short paths:
    from SiEPIC._globals import PIN_LENGTH as pin_length

    t = Trans(Trans.R0, 0,0)
    pin = Path([Point(pin_length/2, 0), Point(-pin_length/2, 0)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin1", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    t = Trans(Trans.R0, length,0)
    pin = Path([Point(-pin_length/2, 0), Point(pin_length/2, 0)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin2", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    # Compact model information
    t = Trans(Trans.R0, 0, 0)
    text = Text ('Lumerical_INTERCONNECT_library=Design kits/ebeam', t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu
    t = Trans(Trans.R0, length/10, 0)
    text = Text ('Component=ebeam_bragg_te1550', t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu
    t = Trans(Trans.R0, length/9, 0)
    text = Text \
      ('Spice_param:number_of_periods=%s grating_period=%.3fu corrugation_width=%.3fu misalignment=%.3fu sinusoidal=%s' %\
      (self.number_of_periods, self.grating_period, self.corrugation_width, self.misalignment, int(self.sinusoidal)), t )
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu

    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
    t = Trans(Trans.R0, 0,0)
    path = Path([Point(0, 0), Point(length, 0)], 3*w)
    shapes(LayerDevRecN).insert(path.simple_polygon())


class Contra_DC(PCellDeclarationHelper):
  """
  Author:   Mustafa Hammood 
                Mustafa@ece.ubc.ca
  """

  def __init__(self):

    # Important: initialize the super class
    super(Contra_DC, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("number_of_periods", self.TypeInt, "Number of grating periods", default = 300)     
    self.param("grating_period", self.TypeDouble, "Grating period (microns)", default = 0.317)
    self.param("gap", self.TypeDouble, "Gap (microns)", default = 0.15)          
    self.param("corrugation_width1", self.TypeDouble, "Waveguide 1 Corrugration width (microns)", default = 0.03)
    self.param("corrugation_width2", self.TypeDouble, "Waveguide 2 Corrugration width (microns)", default = 0.04)          
    self.param("AR", self.TypeBoolean, "Anti-Reflection Coating", default =True)
    self.param("sinusoidal", self.TypeBoolean, "Grating Type (Rectangular=False, Sinusoidal=True)", default = False)     
    self.param("wg1_width", self.TypeDouble, "Waveguide 1 width", default = 0.45)
    self.param("wg2_width", self.TypeDouble, "Waveguide 2 width", default = 0.55)          
    self.param("index", self.TypeDouble, "Gaussian Index", default = 2.8)
    self.param("layer", self.TypeLayer, "Layer", default = TECHNOLOGY['Waveguide'])
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
#    self.param("textl", self.TypeLayer, "Text Layer", default = LayerInfo(10, 0))

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Contra_DC_%s-%.3f" % \
    (self.number_of_periods, self.grating_period)
  
  def coerce_parameters_impl(self):
    pass

  def can_create_from_shape(self, layout, shape, layer):
    return False
    
  def produce_impl(self):
  
    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    shapes = self.cell.shapes

    LayerSi = self.layer
    LayerSiN = ly.layer(LayerSi)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)

    from SiEPIC.extend import to_itype
    
    # Draw the Bragg grating (bottom):
    box_width = int(round(self.grating_period/2/dbu))
    grating_period = int(round(self.grating_period/dbu))
    w = to_itype(self.wg1_width,dbu)
    GaussianIndex = self.index
    half_w = w/2
    half_corrugation_w = int(round(self.corrugation_width1/2/dbu))
    
    if self.AR:
      misalignment = grating_period/2
    else:
      misalignment = 0

    N = self.number_of_periods
    if self.sinusoidal:
      npoints_sin = 40
      for i in range(0,self.number_of_periods):
        x = (round((i * self.grating_period)/dbu))
        profileFunction = math.exp( -0.5*(2*GaussianIndex*(i-N/2)/(N))**2 )
        profile = int(round(self.corrugation_width1/2/dbu))*profileFunction;
        box1 = Box(x, 0, x + box_width, half_w+profile)
        pts1 = [Point(x,0)]
        pts3 = [Point(x + misalignment,0)]
        for i1 in range(0,npoints_sin+1):
          x1 = i1 * 2* math.pi / npoints_sin
          y1 = round(profile*math.sin(x1))
          x1 = round(x1/2/math.pi*grating_period)
#          print("x: %s, y: %s" % (x1,y1))
          pts1.append( Point(x + x1,half_w+y1 ) )
          pts3.append( Point(x + misalignment + x1,-half_w-y1 ) )
        pts1.append( Point(x + grating_period, 0) )
        pts3.append( Point(x + grating_period + misalignment, 0) )
        shapes(LayerSiN).insert(Polygon(pts1))
        shapes(LayerSiN).insert(Polygon(pts3))
      length = x + grating_period + misalignment
      if misalignment &gt; 0:
        # extra piece at the end:
        box2 = Box(x + grating_period, 0, length, half_w)
        shapes(LayerSiN).insert(box2)
        # extra piece at the beginning:
        box3 = Box(0, 0, misalignment, -half_w)
        shapes(LayerSiN).insert(box3)

    else:
    
      
      
      for i in range(0,self.number_of_periods):
        x = int(round((i * self.grating_period)/dbu))
        
        profileFunction = math.exp( -0.5*(2*GaussianIndex*(i-N/2)/(N))**2 )
        profile = int(round(self.corrugation_width1/2/dbu))*profileFunction;
        box1 = Box(x, 0, x + box_width, half_w+profile)
        box2 = Box(x + box_width, 0, x + grating_period, half_w-profile)
        box3 = Box(x + misalignment, 0, x + box_width + misalignment, -half_w-profile)
        box4 = Box(x + box_width + misalignment, 0, x + grating_period + misalignment, -half_w+profile)
        shapes(LayerSiN).insert(box1)
        shapes(LayerSiN).insert(box2)
        shapes(LayerSiN).insert(box3)
        shapes(LayerSiN).insert(box4)
      length = x + grating_period + misalignment
      if misalignment &gt; 0:
        # extra piece at the end:
        box2 = Box(x + grating_period, 0, length, half_w)
        shapes(LayerSiN).insert(box2)
        # extra piece at the beginning:
        box3 = Box(0, 0, misalignment, -half_w)
        shapes(LayerSiN).insert(box3)




    vertical_offset = int(round(self.wg2_width/2/dbu))+int(round(self.gap/dbu))+int(round(self.wg1_width/2/dbu))
    
    if misalignment &gt; 0:
      t = Trans(Trans.R0, 0,vertical_offset)
    else:
      t = Trans(Trans.R0, 0,vertical_offset)
    
    # Draw the Bragg grating (top):
    box_width = int(round(self.grating_period/2/dbu))
    grating_period = int(round(self.grating_period/dbu))
    w = to_itype(self.wg2_width,dbu)
    GaussianIndex = self.index
    half_w = w/2
    half_corrugation_w = int(round(self.corrugation_width2/2/dbu))
    

    N = self.number_of_periods
    if self.sinusoidal:
      npoints_sin = 40
      for i in range(0,self.number_of_periods):
        x = (round((i * self.grating_period)/dbu))
        profileFunction = math.exp( -0.5*(2*GaussianIndex*(i-N/2)/(N))**2 )
        profile = int(round(self.corrugation_width2/2/dbu))*profileFunction;
        box1 = Box(x, 0, x + box_width, -half_w+profile).transformed(t)
        pts1 = [Point(x,0)]
        pts3 = [Point(x + misalignment,0)]
        for i1 in range(0,npoints_sin+1):
          x1 = i1 * 2* math.pi / npoints_sin
          y1 = round(profile*math.sin(x1))
          x1 = round(x1/2/math.pi*grating_period)
#          print("x: %s, y: %s" % (x1,y1))
          pts1.append( Point(x + x1,-half_w-y1 ) )
          pts3.append( Point(x + misalignment + x1,+half_w+y1 ) )
        pts1.append( Point(x + grating_period, 0) )
        pts3.append( Point(x + grating_period + misalignment, 0) )
        shapes(LayerSiN).insert(Polygon(pts1).transformed(t))
        shapes(LayerSiN).insert(Polygon(pts3).transformed(t))
      length = x + grating_period + misalignment
      if misalignment &gt; 0:
        # extra piece at the end:
        box2 = Box(x + grating_period, 0, length, -half_w).transformed(t)
        shapes(LayerSiN).insert(box2)
        # extra piece at the beginning:
        box3 = Box(0, 0, misalignment, half_w).transformed(t)
        shapes(LayerSiN).insert(box3)

    else:
    
      
      
      for i in range(0,self.number_of_periods):
        x = int(round((i * self.grating_period)/dbu))
        
        profileFunction = math.exp( -0.5*(2*GaussianIndex*(i-N/2)/(N))**2 )
        profile = int(round(self.corrugation_width2/2/dbu))*profileFunction;
        box1 = Box(x, 0, x + box_width, -half_w-profile).transformed(t)
        box2 = Box(x + box_width, 0, x + grating_period, -half_w+profile).transformed(t)
        box3 = Box(x + misalignment, 0, x + box_width + misalignment, half_w+profile).transformed(t)
        box4 = Box(x + box_width + misalignment, 0, x + grating_period + misalignment, half_w-profile).transformed(t)
        shapes(LayerSiN).insert(box1)
        shapes(LayerSiN).insert(box2)
        shapes(LayerSiN).insert(box3)
        shapes(LayerSiN).insert(box4)
      length = x + grating_period + misalignment
      if misalignment &gt; 0:
        # extra piece at the end:
        box2 = Box(x + grating_period, 0, length, -half_w).transformed(t)
        shapes(LayerSiN).insert(box2)
        # extra piece at the beginning:
        box3 = Box(0, 0, misalignment, half_w).transformed(t)
        shapes(LayerSiN).insert(box3)
        
         
    # Create the pins on the waveguides, as short paths:
    from SiEPIC._globals import PIN_LENGTH as pin_length

    w = to_itype(self.wg1_width,dbu)
    t = Trans(Trans.R0, 0,0)
    pin = Path([Point(pin_length/2, 0), Point(-pin_length/2, 0)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin1", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu
    
    w = to_itype(self.wg2_width,dbu)
    t = Trans(Trans.R0, 0,vertical_offset)
    pin = Path([Point(pin_length/2, 0), Point(-pin_length/2, 0)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin3", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    w = to_itype(self.wg1_width,dbu)
    t = Trans(Trans.R0, length,0)
    pin = Path([Point(-pin_length/2, 0), Point(pin_length/2, 0)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin2", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu
    
    w = to_itype(self.wg2_width,dbu)
    t = Trans(Trans.R0, length,vertical_offset)
    pin = Path([Point(-pin_length/2, 0), Point(pin_length/2, 0)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin4", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    # Compact model information
    t = Trans(Trans.R0, 0, 0)
    text = Text ('Lumerical_INTERCONNECT_library=Design kits/ebeam', t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu
    t = Trans(Trans.R0, length/10, 0)
    text = Text ('Component=ebeam_contra_dc', t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu
    t = Trans(Trans.R0, length/9, 0)
    text = Text \
      ('Spice_param:number_of_periods=%s grating_period=%.3fu corrugation_width=%.3fu misalignment=%.3fu sinusoidal=%s' %\
      (self.number_of_periods, self.grating_period, self.corrugation_width1, misalignment, int(self.sinusoidal)), t )
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu

    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
    t = Trans(Trans.R0, 0,0)
    path = Path([Point(0, vertical_offset/2), Point(length, vertical_offset/2)], 3*w)
    shapes(LayerDevRecN).insert(path.simple_polygon())
    

class Contra_DC_couplerApodized(PCellDeclarationHelper):
  """
  Author:   Mustafa Hammood 
                Mustafa@ece.ubc.ca
  """

  def __init__(self):

    # Important: initialize the super class
    super(Contra_DC_couplerApodized, self).__init__()
    TECHNOLOGY = get_technology_by_name('EBeam')

    # declare the parameters
    self.param("number_of_periods", self.TypeInt, "Number of grating periods", default = 300)     
    self.param("grating_period", self.TypeDouble, "Grating period (microns)", default = 0.317)
    self.param("gap", self.TypeDouble, "Minimum gap (microns)", default = 0.15)          
    self.param("corrugation_width1", self.TypeDouble, "Waveguide 1 Corrugration width (microns)", default = 0.03)
    self.param("corrugation_width2", self.TypeDouble, "Waveguide 2 Corrugration width (microns)", default = 0.04)          
    self.param("AR", self.TypeBoolean, "Anti-Reflection Coating", default =True)    
    self.param("sinusoidal", self.TypeBoolean, "Grating Type (Rectangular=False, Sinusoidal=True)", default = False)     
    self.param("wg1_width", self.TypeDouble, "Waveguide 1 width", default = 0.45)
    self.param("wg2_width", self.TypeDouble, "Waveguide 2 width", default = 0.55)          
    self.param("index", self.TypeDouble, "Gaussian Index", default = 2.5)
    self.param("H", self.TypeDouble, "Apodization H constant (microns)", default = 2)
    self.param("layer", self.TypeLayer, "Layer", default = TECHNOLOGY['Waveguide'])
    self.param("pinrec", self.TypeLayer, "PinRec Layer", default = TECHNOLOGY['PinRec'])
    self.param("devrec", self.TypeLayer, "DevRec Layer", default = TECHNOLOGY['DevRec'])
#    self.param("textl", self.TypeLayer, "Text Layer", default = LayerInfo(10, 0))

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Contra_DC_%s-%.3f" % \
    (self.number_of_periods, self.grating_period)
  
  def coerce_parameters_impl(self):
    pass

  def can_create_from_shape(self, layout, shape, layer):
    return False
    
  def produce_impl(self):
  
    # fetch the parameters
    dbu = self.layout.dbu
    ly = self.layout
    shapes = self.cell.shapes

    LayerSi = self.layer
    LayerSiN = ly.layer(LayerSi)
    LayerPinRecN = ly.layer(self.pinrec)
    LayerDevRecN = ly.layer(self.devrec)

    from SiEPIC.extend import to_itype
    
    # Draw the Bragg grating (bottom):
    box_width = int(round(self.grating_period/2/dbu))
    grating_period = int(round(self.grating_period/dbu))
    w = to_itype(self.wg1_width,dbu)
    GaussianIndex = self.index
    half_w = w/2
    half_corrugation_w = int(round(self.corrugation_width1/2/dbu))
    
    if self.AR:
      misalignment = grating_period/2
    else:
      misalignment = 0

    N = self.number_of_periods
    if self.sinusoidal:
      npoints_sin = 40
      for i in range(0,self.number_of_periods):
        x = (round((i * self.grating_period)/dbu))
        deltaW1 = int(round(self.corrugation_width1/2/dbu))
        box1 = Box(x, 0, x + box_width, half_w+deltaW1)
        pts1 = [Point(x,0)]
        pts3 = [Point(x + misalignment,0)]
        for i1 in range(0,npoints_sin+1):
          x1 = i1 * 2* math.pi / npoints_sin
          y1 = round(deltaW1*math.sin(x1))
          x1 = round(x1/2/math.pi*grating_period)
#          print("x: %s, y: %s" % (x1,y1))
          pts1.append( Point(x + x1,half_w+y1 ) )
          pts3.append( Point(x + misalignment + x1,-half_w-y1 ) )
        pts1.append( Point(x + grating_period, 0) )
        pts3.append( Point(x + grating_period + misalignment, 0) )
        shapes(LayerSiN).insert(Polygon(pts1))
        shapes(LayerSiN).insert(Polygon(pts3))
      length = x + grating_period + misalignment
      if misalignment &gt; 0:
        # extra piece at the end:
        box2 = Box(x + grating_period, 0, length, half_w)
        shapes(LayerSiN).insert(box2)
        # extra piece at the beginning:
        box3 = Box(0, 0, misalignment, -half_w)
        shapes(LayerSiN).insert(box3)

    else:
    
      
      
      for i in range(0,self.number_of_periods):
        x = int(round((i * self.grating_period)/dbu))
        
        deltaW1 = int(round(self.corrugation_width1/2/dbu))
        box1 = Box(x, 0, x + box_width, half_w+deltaW1)
        box2 = Box(x + box_width, 0, x + grating_period, half_w-deltaW1)
        box3 = Box(x + misalignment, 0, x + box_width + misalignment, -half_w-deltaW1)
        box4 = Box(x + box_width + misalignment, 0, x + grating_period + misalignment, -half_w+deltaW1)
        shapes(LayerSiN).insert(box1)
        shapes(LayerSiN).insert(box2)
        shapes(LayerSiN).insert(box3)
        shapes(LayerSiN).insert(box4)
      length = x + grating_period + misalignment
      if misalignment &gt; 0:
        # extra piece at the end:
        box2 = Box(x + grating_period, 0, length, half_w)
        shapes(LayerSiN).insert(box2)
        # extra piece at the beginning:
        box3 = Box(0, 0, misalignment, -half_w)
        shapes(LayerSiN).insert(box3)

    vertical_offset = int(round(self.wg2_width/2/dbu))+int(round(self.gap/dbu))+int(round(self.wg1_width/2/dbu))
    
    if misalignment &gt; 0:
      t = Trans(Trans.R0, 0,vertical_offset)
    else:
      t = Trans(Trans.R0, 0,vertical_offset)
    
    # Draw the Bragg grating (top):
    box_width = int(round(self.grating_period/2/dbu))
    grating_period = int(round(self.grating_period/dbu))
    w = to_itype(self.wg2_width,dbu)
    GaussianIndex = self.index
    half_w = w/2
    half_corrugation_w = int(round(self.corrugation_width2/2/dbu))
    

    N = self.number_of_periods
    if self.sinusoidal:
      npoints_sin = 40
      for i in range(0,self.number_of_periods):

        periodGap = int(round(self.gap/dbu))
        vertical_offset = int(round(self.wg2_width/2/dbu))+periodGap+int(round(self.wg1_width/2/dbu))
        if misalignment &gt; 0:
          t = Trans(Trans.R0, 0,vertical_offset)
        else:
          t = Trans(Trans.R0, 0,vertical_offset)
      
        x = (round((i * self.grating_period)/dbu))
        deltaW2 = int(round(self.corrugation_width2/2/dbu));
        box1 = Box(x, 0, x + box_width, -half_w+deltaW2).transformed(t)
        pts1 = [Point(x,0)]
        pts3 = [Point(x + misalignment,0)]
        for i1 in range(0,npoints_sin+1):
          x1 = i1 * 2* math.pi / npoints_sin
          y1 = round(deltaW2*math.sin(x1))
          x1 = round(x1/2/math.pi*grating_period)
#          print("x: %s, y: %s" % (x1,y1))
          pts1.append( Point(x + x1,-half_w-y1 ) )
          pts3.append( Point(x + misalignment + x1,+half_w+y1 ) )
        pts1.append( Point(x + grating_period, 0) )
        pts3.append( Point(x + grating_period + misalignment, 0) )
        shapes(LayerSiN).insert(Polygon(pts1).transformed(t))
        shapes(LayerSiN).insert(Polygon(pts3).transformed(t))
      length = x + grating_period + misalignment
      if misalignment &gt; 0:
        # extra piece at the end:
        box2 = Box(x + grating_period, 0, length, -half_w).transformed(t)
        shapes(LayerSiN).insert(box2)
        # extra piece at the beginning:
        box3 = Box(0, 0, misalignment, half_w).transformed(t)
        shapes(LayerSiN).insert(box3)

    else:
    
      
      
      for i in range(0,self.number_of_periods):
        x = int(round((i * self.grating_period)/dbu))
        
        periodGap = int(round(self.gap/dbu)) + 2*int(round(self.H/dbu)) *(1-math.exp( (-self.index*(i-0.5*N)**2)/(N**2) ))
        vertical_offset = int(round(self.wg2_width/2/dbu))+periodGap+int(round(self.wg1_width/2/dbu))
        if misalignment &gt; 0:
          t = Trans(Trans.R0, 0,vertical_offset)
        else:
          t = Trans(Trans.R0, 0,vertical_offset)
          
        deltaW2 = int(round(self.corrugation_width2/2/dbu));
        box1 = Box(x, 0, x + box_width, -half_w-deltaW2).transformed(t)
        box2 = Box(x + box_width, 0, x + grating_period, -half_w+deltaW2).transformed(t)
        box3 = Box(x + misalignment, 0, x + box_width + misalignment, half_w+deltaW2).transformed(t)
        box4 = Box(x + box_width + misalignment, 0, x + grating_period + misalignment, half_w-deltaW2).transformed(t)
        shapes(LayerSiN).insert(box1)
        shapes(LayerSiN).insert(box2)
        shapes(LayerSiN).insert(box3)
        shapes(LayerSiN).insert(box4)
      length = x + grating_period + misalignment
      if misalignment &gt; 0:
        # extra piece at the end:
        box2 = Box(x + grating_period, 0, length, -half_w).transformed(t)
        shapes(LayerSiN).insert(box2)
        # extra piece at the beginning:
        box3 = Box(0, 0, misalignment, half_w).transformed(t)
        shapes(LayerSiN).insert(box3)
        
         
    # Create the pins on the waveguides, as short paths:
    from SiEPIC._globals import PIN_LENGTH as pin_length

    w = to_itype(self.wg1_width,dbu)
    t = Trans(Trans.R0, 0,0)
    pin = Path([Point(pin_length/2, 0), Point(-pin_length/2, 0)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin1", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu
    
    w = to_itype(self.wg2_width,dbu)
    t = Trans(Trans.R0, 0,vertical_offset)
    pin = Path([Point(pin_length/2, 0), Point(-pin_length/2, 0)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin3", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    w = to_itype(self.wg1_width,dbu)
    t = Trans(Trans.R0, length,0)
    pin = Path([Point(-pin_length/2, 0), Point(pin_length/2, 0)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin2", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu
    
    w = to_itype(self.wg2_width,dbu)
    t = Trans(Trans.R0, length,vertical_offset)
    pin = Path([Point(-pin_length/2, 0), Point(pin_length/2, 0)], w)
    pin_t = pin.transformed(t)
    shapes(LayerPinRecN).insert(pin_t)
    text = Text ("pin4", t)
    shape = shapes(LayerPinRecN).insert(text)
    shape.text_size = 0.4/dbu

    # Compact model information
    t = Trans(Trans.R0, 0, 0)
    text = Text ('Lumerical_INTERCONNECT_library=Design kits/ebeam', t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu
    t = Trans(Trans.R0, length/10, 0)
    text = Text ('Component=ebeam_contra_dc', t)
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu
    t = Trans(Trans.R0, length/9, 0)
    text = Text \
      ('Spice_param:number_of_periods=%s grating_period=%.3fu corrugation_width=%.3fu misalignment=%.3fu sinusoidal=%s' %\
      (self.number_of_periods, self.grating_period, self.corrugation_width1, misalignment, int(self.sinusoidal)), t )
    shape = shapes(LayerDevRecN).insert(text)
    shape.text_size = 0.1/dbu

    # Create the device recognition layer -- make it 1 * wg_width away from the waveguides.
    t = Trans(Trans.R0, 0,0)
    path = Path([Point(0, vertical_offset/2), Point(length, vertical_offset/2)], 3*w)
    shapes(LayerDevRecN).insert(path.simple_polygon())
    
class SiEPIC_EBeam_dev(Library):
  """
  The library where we will put the PCells and GDS into 
  """

  def __init__(self):

    tech_name = 'EBeam'
    library = tech_name+'-dev'
    
    print("Initializing '%s' Library." % library)


    # Set the description
# windows only allows for a fixed width, short description 
    self.description = ""
# OSX does a resizing:
#    self.description = "Beta layouts only"

    import os
    self.layout().read(os.path.join(os.path.dirname(os.path.realpath(__file__)), "SiEPIC-EBeam-dev.gds"))
#    [self.layout().rename_cell(i, self.layout().cell_name(i).replace('_', ' ')) for i in range(0, self.layout().cells())]
    
    
    # Create the PCell declarations


    self.layout().register_pcell("DirectionalCoupler_SeriesRings", DirectionalCoupler_SeriesRings())
    self.layout().register_pcell("ebeam_dc_halfring_arc", ebeam_dc_halfring_arc())
    self.layout().register_pcell("DoubleBus_Ring", DoubleBus_Ring())
    self.layout().register_pcell("TestStruct_DoubleBus_Ring", TestStruct_DoubleBus_Ring())
    self.layout().register_pcell("TestStruct_DoubleBus_Ring2", TestStruct_DoubleBus_Ring2())
#    self.layout().register_pcell("Waveguide_Route", Waveguide_Route())
#    self.layout().register_pcell("Waveguide_Route_simple", Waveguide_Route_simple())
    self.layout().register_pcell("Waveguide_Arc", Waveguide_Arc())
    self.layout().register_pcell("Bent_Coupled_Half_Ring", Bent_Coupled_Half_Ring())
    self.layout().register_pcell("Bent_Contra_DC", Bent_Contra_DC())
    self.layout().register_pcell("Bezier_Bend", Bezier_Bend())
    self.layout().register_pcell("Cavity Hole", cavity_hole())
    self.layout().register_pcell("Tapered Ring", Tapered_Ring())
    self.layout().register_pcell("Focusing Sub-wavelength grating coupler (fswgc)", fswgc() )
    self.layout().register_pcell("SWG_waveguide", SWG_waveguide())
    self.layout().register_pcell("SWG_to_strip_waveguide", SWG_to_strip_waveguide())
    self.layout().register_pcell("strip_to_slot", strip_to_slot() )
    #self.layout().register_pcell("Spiral", spiral())
    self.layout().register_pcell("Apodized Bragg Grating", ebeam_bragg_apodized())
    self.layout().register_pcell("Contra-Directional Coupler", Contra_DC())
    self.layout().register_pcell("Contra-Directional Coupler (coupler apodized)", Contra_DC_couplerApodized())

    import PCMSpiral_PCells as spirals
    self.layout().register_pcell("Spiral_BraggGrating", spirals.PCMSpiralBraggGrating())
    self.layout().register_pcell("Spiral_BraggGrating_Slab", spirals.PCMSpiralBraggGratingSlab())
    self.layout().register_pcell("Spiral_NoCenterBraggGrating", spirals.Spiral_NoCenterBraggGrating())
    self.layout().register_pcell("Spiral_CDC_BraggGrating", spirals.CDCSpiralBraggGrating())
    self.layout().register_pcell("SpiralWaveguide", spirals.SpiralWaveguide())

    # only need to reload if we are debugging, and are making changes to the code
    if sys.version_info[0] == 3:
        if sys.version_info[1] &lt; 4:
            from imp import reload
        else:
            from importlib import reload
    elif sys.version_info[0] == 2:
        from imp import reload

    spirals = reload(spirals)

    try:  # in case there are errors, e.g., missing numpy
      from photonic_crystals import photonic_crystals
      photonic_crystals = reload(photonic_crystals)
  
  #    self.layout().register_pcell("SWG Fibre Coupler - litho test", swg_fc_test())
      self.layout().register_pcell("SWG Fibre Grating Coupler", photonic_crystals.swg_fc())
      self.layout().register_pcell("PhC H0 cavity with waveguide", photonic_crystals.H0c())
      self.layout().register_pcell("PhC L3 cavity with waveguide", photonic_crystals.L3c())
      self.layout().register_pcell("PhC H0 cavity with waveguide, no etching", photonic_crystals.H0c_oxide())
      self.layout().register_pcell("PhC H0 cavity with waveguide, with hexagon cell", photonic_crystals.H0c_new())
  #    self.layout().register_pcell("PhC hole resolution test structure", photonic_crystals.PhC_test())
  #    self.layout().register_pcell("Half of the hole cell", photonic_crystals.Hole_cell_half())
  #    self.layout().register_pcell("Half of the hexagon cell", photonic_crystals.Hexagon_cell_half())
  #    self.layout().register_pcell("Waveguide Triangle Tapers", photonic_crystals.wg_triangle_tapers())
  #    self.layout().register_pcell("PhC H0c Test Structure", photonic_crystals.H0c_Test_Structure())
  #    self.layout().register_pcell("PhC H0c oxide Test Structure", photonic_crystals.H0c_oxide_Test_Structure())
  #    self.layout().register_pcell("PhC L3c Test Structure", photonic_crystals.L3c_Test_Structure())
  #    self.layout().register_pcell("Grating Coupler to Grating Coupler Reference Device", photonic_crystals.GC_to_GC_ref1())
      self.layout().register_pcell("PhC W1 Waveguide", photonic_crystals.PhC_W1wg()) 
  #    self.layout().register_pcell("PhC W1 Reference Structure", photonic_crystals.PhC_W1wg_reference())
    except:
      pass
    
    # Register us the library with the technology name
    # If a library with that name already existed, it will be replaced then.
    self.register(library)

    if int(Application.instance().version().split('.')[1]) &gt; 24:
      # KLayout v0.25 introduced technology variable:
      self.technology=tech_name

# Setup path to load .py files in present folder:
import os, inspect, sys
path = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
if not path in sys.path:
  sys.path.append(path)

# Instantiate and register the library
SiEPIC_EBeam_dev()



</text>
</klayout-macro>
